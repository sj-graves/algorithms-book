<?xml version='1.0' encoding='utf-8'?>

<section xml:id="sec-crypto-classic" xmlns:xi="http://www.w3.org/2001/XInclude">
    <title>Other classical ciphers</title>
    <introduction>
        <p>
            Beyond simple substitution there are several other interesting historical encryption schemes. The first we investigate is Playfair's Cipher, which performs a simple permutation on <term>digraphs</term> (two-letter words). Then we will discuss <term>polyalphabetic substitution</term> ciphers, which rely on a changing permutation to provide the encryption. Polyalphabetic substitutions are both historically relevant and theoretically interesting, as a particular type of polyalphabetic substitution gives us a provably unbreakable encryption method!
        </p>
    </introduction>
    <!-- ################################### -->
    <subsection xml:id="sub-crypto-classic-digraphs">
        <title>Increasing the alphabet: Playfair's cipher</title>
        <p>
            Since we see that a little frequency analysis can go a long way towards decryption when we permute characters, we have to consider another method which makes the frequency-analysis approach more difficult. The method known as <term>Playfair's cipher</term> was first developed in 1854 by Charles Wheatstone, but popularized by Lyon Playfair, 1st Baron Playfair, and was in continuous use up through World War II. The principle benefit to Playfair is the simplicity of its execution by hand. At the same time, it shifts the alphabet of the permutation from an alphabet of 26 letters to an alphabet of 600 <term>digraphs</term>. Unfortunately there are certain characteristics of the permutations generated by Playfair's cipher that lend themselves to mathematical analysis.
        </p>
        <algorithm xml:id="algo-playfair_cipher">
            <title>Playfair's cipher</title>
            <p>
                Assume that we have a string <c>pmsg</c> consisting of a message written in English plaintext which we wish to encrypt via Playfair.
            </p>
            <p>
                <ol>
                    <li><p>
                        Choose and share a key phrase, a short English plaintext.
                        </p></li>
                    <li><p>
                        Pre-process the key phrase into the <term>Playfair grid</term> using <xref ref="algo-playfair_key_preprocessing" />.
                        </p></li>
                    <li><p>
                        Process the plaintext <c>pmsg</c> into encryptable digraphs using <xref ref="algo-playfair_creating_digraphs" />.
                        </p>
                    </li>
                    <li><p>
                        Create an empty list <c>enc_digraphs</c> to eventually contain all of the encrypted digraphs.
                        </p></li>
                    <li><p>
                        Perform Playfair's cipher on each entry of the list <c>digraphs</c> one at a time using <xref ref="algo-playfair_encrypting_digraphs" />, adding the encrypted version of each to <c>enc_digraphs</c>.
                        </p>
                    </li>
                </ol>
            </p>
        </algorithm>
        <p>
            The technical details of each of those subalgorithms appear at the bottom of this section, but it is much easier to describe the process with an example than it is to write a correct and rigorous algorithm.
        </p>
        <example xml:id="exmp-applying_playfair">
            <title>Applying Playfair's cipher</title>
            <!-- SHARED SECRET -->
            <p>
                To perform Playfair's cipher, the first step is to generate a shared secret, called the <term>key phrase</term>. This can be any memorable phrase in the target alphabet. For instance, we could choose the phrase <q>Go Patriots! Talons up!</q> in an excess of school spirit. Next we have to clean up the passphrase, which takes a few steps. First, convert all alphabetic characters to capitals, throw away all non-alphabetic characters, and append the alphabet <m>\mathcal{E}</m> to the end of the key phrase. For our example, that would give us
            </p>
            <program>
                <input>
                    GOPATRIOTSTALONSUPABCDEFGHIJKLMNOPQRSTUVWXYZ
                </input>
            </program>
            <p>
                Next, replace all <c>I</c> characters with <c>J</c> characters. This is necessary as the algorithm relies on a 25-letter alphabet, and since <c>J</c> looks similar to <c>I</c> but is an uncommon letter we merge all the <c>I</c> and <c>J</c> characters together. Then remove all multiple instances of a letter. This process applied to our key phrase results in a pre-processed key phrase of
            </p>
            <program>
                <input>
                    GOPATRJSLNUBCDEFHKMQVWXYZ
                </input>
            </program>
            <!-- PLAYFAIR GRID -->
            <p>
                Now we write the <term>Playfair grid</term>. In a <m>5\times 5</m> grid, starting in the top left, write the letters of the pre-processed key phrase. For our key phrase, this produces the following:
            </p>
            <figure xml:id="fig-playfair_grid">
                <caption>Playfair grid for the key phrase <q>Go Patriots! Talons up!</q></caption>
                <image xml:id="img-playfair_grid" width="30%">
                    <xi:include href="img_playfair_grid.ptx" />
                </image>
            </figure>
            <p>
                The grid provides the permutation of digraphs in a rather clever way, and it's a <term>symmetric key</term>, meaning that the same key (the grid itself) is used to encrypt messages as is used to decrypt ciphertexts. As a message, suppose we want to encrypt the ridiculous message <q>The bookkeeper remains sequestered. The suq question remains bizarre. Tax Xavier.</q> This message is chosen because it has many double letters, which have to be treated carefully in another pre-processing step.
            </p>
            <p>
                Convert the message to capitals, then replace all <c>I</c> characters with <c>J</c>. We begin breaking our message into two-letter pairs called <term>digraphs</term>, but we never want a digraph to contain the same letter twice. When that happens, we will insert an <c>X</c> between the two letters, unless the letters are both <c>X</c>; in that case, insert a <c>Q</c>. This turns our message into the following: </p>
            <program>
                <input>
                    TH EB OX OK KE EP ER RE MA JN SX SE
                    QU ES TE RE DT HE SU QX QU ES TJ ON
                    RE MA JN SB JZ AR RE TA XQ XA VJ ER
                </input>
            </program>
            <!-- Applying encryption -->
            <p>
                To encrypt this processed message, we work one digraph at a time, drawing a box in the Playfair grid around each pair of letters. For the digraph <c>TH</c> in our grid, that looks like this:
            </p>
            <figure xml:id="fig-playfair-boxed">
                <caption>Playfair grid for the key phrase <q>Go Patriots! Talons up!</q> with the digraph <c>TH</c> boxed in red, <c>EB</c> boxed in blue, and <c>MA</c> boxed in green.</caption>
                <image xml:id="img-playfair-boxed" width = "30%">
                    <xi:include href="img_playfair_boxed.ptx" />
                </image>
            </figure>
            <p>
                With the digraph boxed, there are three possible next steps.
            </p>
            <p>
                <ul>
                    <li><p>
                        <em>Normal:</em> If the box intersects more than one row and more than one column, then letters in the corners of the box are used to replace the digraph. The upper left letter replaces the upper right letter (and vice versa) and the lower left letter replaces the lower right letter (and vice versa). In <xref ref="fig-playfair-boxed" /> this will result in the digraph <c>TH</c> mapping to <c>OQ</c>.
                        </p></li>
                    <li><p>
                        <em>Right shift</em>: If the box is all on one line in the grid, the box shifts one unit to the right, wrapping around the grid if necessary. The left letter of the old box is now replaced by the left letter of the new box, while the right letter of the old box is now replaced by the right letter of the new box. In <xref ref="fig-playfair-boxed" /> this will result in the digraph <c>EB</c> being replaced by <c>UC</c>.
                        </p></li>
                    <li><p>
                        <em>Down shift</em>: If the box is all on one column of the grid, the box shifts one unit down, and the similar process is followed as when the letters were in the same row. In <xref ref="fig-playfair-boxed" /> this will result in the digraph <c>MA</c> being replaced by <c>YL</c>.
                        </p></li>
                </ul>
            </p>
            <p>
                Following these steps for each digraph, we obtain the following result, where the input digraph appears on the row above the output digraph.
            </p>
            <console>
                <output>
                    TH EB OX OK KE EP ER RE MA JN SX SE QU ES TE RE DT HE
                    OQ UC PW PH QC CT UN NU YL SR CP NC FE CN NQ NU EA QB
                </output>
                <output>
                    SU QX QU ES TJ ON RE MA JN SB JZ AR RE TA XQ XA VJ ER
                    RC KZ FE CN ON TJ NU YL SR JC NW GL NU GT ZK YP WR UN
                </output>
            </console>
            <p>
                Frequently the ciphertext will be displayed in blocks of a fixed number of characters. Using an odd block size might incline a spy to think that Playfair's cipher was not being used! To reverse Playfair's cipher and decrypt our blocked ciphertext
            </p>
            <program>
                <input>
                    OQUCPWPHQ CCTUNNUYL SRCPNCFEC NNQNUEAQB
                    RCKZFECNO NTJNUYLSR JCNWGLNUG TZKYPWRUN
                </input>
            </program>
            <p> we simply feed the ciphertext back into the same grid, but this time use a left shift instead of right shift and an up shift instead of a down shift.
            </p>
        </example>
        <p>
         The particulars of the subalgorithms of Playfair's cipher appear here.
        </p>
        <algorithm xml:id="algo-playfair_key_preprocessing">
            <title>Playfair's cipher: pre-processing the key phrase</title>
            <p>
                Suppose <c>key_phrase</c> is a string consisting of the original chosen key phrase.
            </p>
            <p>
                <ol>
                <li><p>
                    Convert all alphabetic characters of <c>key_phrase</c> into capitals and discard any non-alphabetic characters.
                    </p></li>
                <li><p>
                    Add the full alphabet <m>\mathcal{E}</m> to the end of <c>key_phrase</c>, in normal alphabetic order.
                    </p></li>
                <li><p>
                    Replace all <c>I</c> characters in <c>key_phrase</c> with a <c>J</c>.
                    </p></li>
                <li><p>
                    Remove all repetitions of a character from <c>key_phrase</c> until what is left is a list of 25 non-repeating capital letters.
                    </p></li>
                <li><p>
                    Write these 25 characters into the positions of a <m>5\times 5</m> grid, beginning at the top left entry. This is the <term>Playfair grid</term>.
                    </p></li>
                </ol>
            </p>
        </algorithm>
        <algorithm xml:id="algo-playfair_creating_digraphs">
            <title>Playfair's cipher: creating digraphs from an original message</title>
            <p>
                Suppose that <c>pmsg</c> is a string consisting of a plaintext written in English.
            </p>
            <p>
                <ol>
                    <li><p>
                        Convert all alphabetic characters of <c>pmsg</c> into capitals and discard any non-alphabetic characters.
                        </p></li>
                    <li><p>
                        From <c>pmsg</c>, create a list <c>digraphs</c> of two-character words.
                        <ol>
                            <li><p>
                                Suppose that <c>x1</c> and <c>x2</c> are the first two unused characters of <c>pmsg</c>.
                                </p></li>
                            <li><p>
                                If <c>x1 != x2</c>, then add <c>x1+x2</c> to the end of the list <c>digraphs</c>. Both <c>x1</c> and <c>x2</c> have now been used.
                                </p></li>
                            <li><p>
                                If <c>x1 == x2</c> but <c>x1 != 'X'</c>, then add <c>x1+'X'</c> to the end of the list <c>digraphs</c>. On the other hand, if <c>x1 == 'X'</c>, add <c>x1+'Q'</c> to the end of <c>digraphs</c>. In either case, <c>x1</c> has been used but <c>x2</c> is still an unused character of <c>pmsg</c>.
                                </p></li>
                            <li><p>
                                In the event that only one letter remains unused at the end of this process, add <c>x1+'X'</c> to <c>digraphs</c> if the last letter of <c>pmsg</c> is <c>x1 != 'X'</c>, or add <c>x1+'Q'</c> to <c>digraphs</c> if the last letter of <c>pmsg</c> is <c>x1 == 'X'</c>.
                                </p></li>
                        </ol></p></li>
                </ol>
            </p>
        </algorithm>
        <algorithm xml:id="algo-playfair_encrypting_digraphs">
            <title>Playfair's cipher: encrypting digraphs</title>
            <p>
                Suppose that <c>key_phrase</c> is a string consisting of a key phrase pre-processed via <xref ref="algo-playfair_key_preprocessing" text="title"/> and that <c>digraphs</c> is a list of digraphs from the English alphabet, with no letter repeated within a digraph and no characters <c>I</c>.
            </p>
            <p>
                <ol>
                    <li><p>
                        If using Playfair's cipher to encrypt a message from plaintext to a ciphertext, let <c>shift = 1</c>. If using the cipher to decrypt an already encrypted message, let <c>shift = -1</c>.
                        </p></li>
                    <li><p>
                        Suppose <c>x1+x2</c> is in the list <c>digraphs</c>, where each of <c>x1</c> and <c>x2</c> is a single-character string.
                        </p></li>
                    <li><p>
                        Let <c>r1</c> and <c>c1</c> respectively be the row index and column index of <c>x1</c> in the Playfair grid, while <c>r2</c> and <c>c2</c> are respectively the row index and column index oc <c>x2</c> in the Playfair grid. All of <c>r1,c1,r2,c2</c> will be elements of <c>range(5)</c>.
                        </p></li>
                    <li><p>
                        If <c>r1 == r2</c>, then both entries are in the same row. Let <c>R1 = R2 = r1</c> and let <c>C1 = (c1 + shift) % 5</c> and <c>C2= (c2 + shift) % 5</c>.
                        </p></li>
                    <li><p>
                        Else if <c>c1 == c2</c>, then both entries are in the same column. Let <c>R1 = (r1 + shift) % 5</c>, <c>R2 = (r2 + shift) % 5</c>, and <c>C1 = C2 = c1</c>.
                        </p></li>
                    <li><p>
                        Else it must be the case that <c>r1 != r2</c> and <c>c1 != c2</c>, since it cannot be that <c>x1 == x2</c>. In this case, let <c>R1 = r1</c> and <c>R2 = r2</c>, but set <c>C1 = c2</c> and <c>C2 = c1</c>.
                        </p></li>
                    <li><p>
                        The encrypted version of <c>x1</c> is the character <c>y1</c> in Playfair grid row <c>R1</c> and column <c>C1</c>, and the encrypted version of <c>x2</c> is the character <c>y2</c> in Playfair grid row <c>R2</c> and column <c>C2</c>.
                        </p></li>
                </ol>
            </p>
        </algorithm>
    </subsection>
    <!-- ################################### -->
    <subsection xml:id="sub-crypto-classic-poly">
        <title>Polyalphabetic substitution</title>
        <introduction>
            <p>
                Polyalphabetic substitution is perhaps a poor name for these systems, which still have one alphabet but change the permutation used from character to character. More plainly, there is some sequence <m>(\sigma_0,\sigma_1,\sigma_2,\dotsc,\sigma_{k-1})</m> of permutations such that a message <m>a_0a_1a_2\cdots a_n</m> is encrypted to <me>\sigma_0(a_0)\sigma_1(a_1)\sigma_2(a_2)\cdots \sigma_{n\rem k}(a_n)</me>.
            </p>
        </introduction>
        <!-- ################################### -->
        <subsubsection xml:id="ssub-crypto-classic-tabularecta">
            <title>The tabula recta</title>
            <p>
                For several polyalphabetic ciphers, the mechanism for performing the encryption is the same. The following matrix is called the <term>tabula recta</term>, depicted with row and column labels in the following:
                <me>
                    \begin{array}{c|ccccccc}
                        \amp A \amp B \amp C \amp D \amp \cdots \amp Y \amp Z \\ \hline
                             A \amp      A \amp      B \amp      C \amp      D \amp \cdots \amp      Y \amp      Z \\
                             B \amp      B \amp      C \amp      D \amp      E \amp \cdots \amp      Z \amp      A \\
                             C \amp      C \amp      D \amp      E \amp      F \amp \cdots \amp      A \amp      B \\
                        \vdots \amp \vdots \amp \vdots \amp \vdots \amp \vdots \amp \ddots \amp \vdots \amp \vdots \\
                             Z \amp      Z \amp      A \amp      B \amp      C \amp \cdots \amp      X \amp      Y
                    \end{array}
                </me>
            </p>
            <p>
                The typical usage of the tabula recta is to pair an input letter designating the row of the matrix with a key letter, designating the column. The letter found in that row and column combination is then the encrypted version of that input under that key letter. The original use of the tabula recta in the <term>Trithemius cipher</term> used a repeating key of <c>ABCDEF...Z</c>. This makes the Trithemius cipher a modified shift cipher where the letter in index <m>k</m> of the message is shifted by <m>k\rem 26</m> positions. The message <c>HELLO STUDENTS</c> would be transformed to <c>HFNOS YACMOYFF</c> under the Trithemius cipher.
            </p>
        </subsubsection>
        <subsubsection xml:id="ssub-crypto-classic-vigenere">
            <title>Vigen&#232;re ciphers and the index of coincidence</title>
            <p>
                A cipher invented by Giovan Battista Bellaso in the 1500s (but misattributed in the 1800s to Vigen&#232;re) improves upon this by adding a less predictable keyword. Rather than using the alphabet as the keyword, a different word is chosen and repeated to match the length of the message. This repeating keyphrase is then used to generate the shift used by applying the tabula recta. With a key phrase of <c>GOPATS</c> repeated to <c>GOPAT SGOPATSG</c> to match the length of <c>HELLO STUDENTS</c> produces the encrypted phrase <c>NSALH YHJDXFZG</c>.
            </p>
            <p>
                Unfortunately when the key phrase is too short these ciphers are vulnerable to another attack involving frequency analysis, this time coupled with a tool called the <term>index of coincidence</term>, <m>IC</m>. Calculating the index of coincidence of a text and comparing it to the expected index of coincidence for the language permits the detection of a likely shift cipher. In the very specific circumstance that you believe a Vigen&#232;re cipher with a short key phrase has been used to encrypt a message, you can compute a <m>\delta</m> index of coincidence, which calculates the <m>IC</m> for each string obtained by skipping <m>\delta</m> characters at a time. If all such skipping strings show an <m>IC</m> value close to the original language, it is likely that the correct key phrase length has been detected.
            </p>
            <p>
                Having detected the length <m>k</m> of the key phrase, you next have to examine the letter frequencies in the skipping strings to the expected letter frequencies, to make a best guess at the value of the shift cipher used on each character. It is a relatively safe guess that the encrypted version of the letter <c>E</c> will be one of the 5-most-frequent letters in each skipping string; hence with a value of <m>k=5</m> you will likely have to check around <m>5^5=3125</m> different possible key phrases by brute force to find the actual key phrase.
            </p>
        </subsubsection>
        <subsubsection xml:id="ssub-crypto-classic-onetimepad">
            <title>One-time pads</title>
            <p>
                A modification to the Vigen&#232;re cipher renders it provably unbreakable. What this specifically means is that all equal-length plaintexts have an equal likelihood of encrypting to the same ciphertext; the modifications, however, are absolutely critical for this. Specifically, the pass phrase must be <em>randomly generated</em>, <em>never reused</em>, and <em>longer than the plaintext</em>. Under these conditions, the pass phrase is called a <term>one-time pad</term>, and Claude Shannon proved that any unbreakable encryption must be equivalent to a one-time pad.
            </p>
        </subsubsection>
    </subsection>
    <subsection xml:id="sub-crypto-classic-enigma">
        <title>The Enigma cipher</title>
        <p>
            The most complicated encryption scheme devised prior to the invention of the modern computer actually led to the development of the modern computer, in a very real way. The Enigma cipher is a polyalphabetic substiution cipher built as an electromechanical encryption device. The device consists of a keyboard where letters are typed, a plugboard, several rotors, a reflector, and a lightboard where encrypted (or decrypted) letters are displayed. The plugboard acts as an <term>involution</term>, which is a permutation <m>S</m> such that <m>S^2 = (1)</m>. If there are <m>k</m> rotors, each acts as a permutation <m>R_i</m> for <m>i\in[k]</m>, and the reflector acts as a final involution <m>M</m>. When a key <m>x</m> is pressed, the lightboard displays the letter corresponding to
            <me>
                y = (SR_0^{-1}R_1^{-1}\cdots R_{k-1}^{-1}MR_{k-1}R_{k-2}\cdots R_0 S)(x)
            </me>.
        </p>
        <p>
            If this were the only complication of the Enigma device, it would be a very physically complicated monoalphabetic substitution. The genius of the Enigma is that when a key is pressed, a rotation mechanism would engage. The right rotor <m>R_0</m> would step, and upon reaching a notch in its mechanism would make the middle rotor step. This in turn could turn the left rotor in the same way. Of the eight rotors in use during World War II, rotors VI, VII, and VIII each had two such notches, providing an irregular stepping to break up the odometer-style pattern of rotor stepping. The result of this stepping mathematically is equivalent to shifting <em>just the bottom row</em> of the two-line notation for that rotor's permutation by one position to the left. It is this stepping which makes Enigma polyalphabetic <mdash /> the permutation changes with each letter encrypted.
        </p>
        <p>
            A further feature of the Enigma machine is that every setting of rotors and plugboard results in a <em>derangement</em>. This feature was patented prior to World War II, when Enigma was sold commercially, and greatly aided Polish algebraist Marian Rejewski in his work to break the encryption. The Polish <em>bombe</em> machine was another electro-mechanical device, this one invented to break the Enigma code; it was refined by Alan Turing at the Bletchley Park codebreaking office in Englad during World War II and used as a major part of the war effort to decrypt Nazi transmissions. These devices in turn led to the Colossus project, which created the world's first programmable, electronic, digital computer.
        </p>
        <definition xml:id="def-derangement">
            <title>Derangement</title>
            <statement>
                <p>
                    Let <m>A</m> be a set. A permutation <m>\delta:A\to A</m> is a <term>derangement</term> if and only if <m>\supp{\delta} = A</m>; that is, <m>\delta(a)\neq a</m> for every <m>a\in A</m>.
                </p>
            </statement>
        </definition>
    </subsection>
  <!--
  <xi:include href=".subsec-emp-intro.ptx" />
  <xi:include href=".subsec-emp-next.ptx" />
  <xi:include href=".subsec-emp-conc.ptx" />
  -->

</section>

