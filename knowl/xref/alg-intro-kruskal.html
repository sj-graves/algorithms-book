<!DOCTYPE html>
<html lang="en-US" dir="ltr">
<!--********************************************-->
<!--*       Generated from PreTeXt source      *-->
<!--*                                          *-->
<!--*         https://pretextbook.org          *-->
<!--*                                          *-->
<!--********************************************-->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="robots" content="noindex, nofollow">
</head>
<body class="ignore-math">
<article class="algorithm theorem-like"><h4 class="heading">
<span class="type">Algorithm</span><span class="space"> </span><span class="codenumber">1.1.5</span><span class="period">.</span><span class="space"> </span><span class="title">Mathematical Kruskal’s Algorithm.</span>
</h4>
<div class="para logical">
<div class="para">Let a graph <span class="process-math">\(G=(V,E)\)</span> with vertex set <span class="process-math">\(V=\set{0,1,2,\dotsc,n-1}\)</span> be given which has a cost <span class="process-math">\(w(e)\)</span> associated with each edge <span class="process-math">\(e\text{.}\)</span> Each edge will be denoted <span class="process-math">\((u,v)\)</span> with <span class="process-math">\(u\lt v\text{,}\)</span> where <span class="process-math">\(u,v\in V\text{.}\)</span>
</div>
<ol class="decimal">
<li><div class="para">Sort the edges by increasing cost, so that whenever <span class="process-math">\(i\lt j\)</span> then also <span class="process-math">\(w(e_i)\leq w(e_j)\text{,}\)</span> where <span class="process-math">\(i\)</span> and <span class="process-math">\(j\)</span> are “counting variables”.</div></li>
<li><div class="para">Write <span class="process-math">\(n\)</span> different sets representing components of the network, denoted <span class="process-math">\(c_v=\set{v}\)</span> for each <span class="process-math">\(v\in V\text{.}\)</span> Also let <span class="process-math">\(F=\emptyset\)</span> be an empty collection of edges.</div></li>
<li><div class="para logical">
<div class="para">Looking at each edge <span class="process-math">\(e_i=(u_i,v_i)\)</span> in increasing order of cost, do the following.</div>
<ol class="lower-alpha">
<li><div class="para">If <span class="process-math">\(u_i\)</span> and <span class="process-math">\(v_i\)</span> are in the same component, skip immediately to the next edge.</div></li>
<li><div class="para logical">
<div class="para">Otherwise, say that <span class="process-math">\(c_u\)</span> is the component containing <span class="process-math">\(u_i\)</span> and <span class="process-math">\(c_v\)</span> is the component containing <span class="process-math">\(v_i\text{,}\)</span> and do the following:</div>
<ol class="lower-roman">
<li><div class="para">If <span class="process-math">\(c_u\)</span> contains fewer vertices than <span class="process-math">\(c_v\text{,}\)</span> put all of the elements from <span class="process-math">\(c_u\)</span> into <span class="process-math">\(c_v\)</span> instead and leave <span class="process-math">\(c_u\)</span> empty.</div></li>
<li><div class="para">Otherwise, put all of the elements from <span class="process-math">\(c_v\)</span> into <span class="process-math">\(c_u\)</span> and leave <span class="process-math">\(c_v\)</span> empty.</div></li>
<li><div class="para">In either case, include the edge <span class="process-math">\((u_i,v_i)\)</span> in <span class="process-math">\(F\text{.}\)</span>
</div></li>
</ol>
</div></li>
</ol>
</div></li>
</ol>
</div> <div class="para">After Step 3 finishes, all of the edges will have been inspected and either included in the network or skipped; there will be as many nonempty components <span class="process-math">\(c_v\)</span> as needed to connect the network, and the algorithm is finished! The cost-minimal set of edges is <span class="process-math">\(F\text{.}\)</span>
</div></article><span class="incontext"><a class="internal" href="sec-intro-mst.html#alg-intro-kruskal">in-context</a></span>
</body>
</html>
