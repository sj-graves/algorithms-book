<!DOCTYPE html>
<html lang="en-US">
<!--********************************************-->
<!--*       Generated from PreTeXt source      *-->
<!--*                                          *-->
<!--*         https://pretextbook.org          *-->
<!--*                                          *-->
<!--********************************************-->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="robots" content="noindex, nofollow">
</head>
<body class="ignore-math">
<figure class="listing figure-like"><div class="code-box" style="width: 100%; margin-left: 0%; margin-right: 0%;"><pre class="program"><code class="language-py">def palu(self, debug=False):
    m,n = self.dims()
    if m!=n: raise ValueError("Cannot PA=LU decompose nonsquare matrix.")
    # Initialize grids
    grid = [[entry for entry in row] for row in self._data] # Skim the data
    pmat = [[1 if r==c else 0 for c in range(n)] for r in range(m)]
    debug_out = []
    # Start at upper left
    r,c = 0,0
    while (r &lt; m) and (c &lt; n):
        # Check if rows need swapped
        debug_out.append( str(grid) )
        cur_max = abs(grid[r][c])
        piv = r
        for r_prime in range(r+1, m):
            if abs(grid[r_prime][c]) &gt; cur_max:
                cur_max = abs(grid[r_prime][c])
                piv = r_prime
        # if cur_max == 0, shift right.
        if cur_max == 0:
            c += 1
            continue
            # otherwise check if rows need swapped
        elif piv != r:
            debug_out.append(f"Swap R({r})&lt;-&gt;R({r_prime})")
            # interchange elements of lists
            grid[piv],grid[r] = grid[r],grid[piv]
            pmat[piv],pmat[r] = pmat[r],pmat[piv]
        # No scaling
        # Elimination
        for r_prime in range(r+1, m):
            if grid[r_prime][c] == 0: continue
            alpha = grid[r_prime][c] / grid[r][c]
            # Since we want to maintain the lower-triangular part for L, we only alter
            # columns c+1 through n of grid[r_prime]
            grid[r_prime][c+1:] = [-alpha*grid[r][c_prime] + grid[r_prime][c_prime] for c_prime in range(c+1,n)]
            # Then store the alpha value in grid[r_prime][c] to pull out for L later
            grid[r_prime][c] = alpha
            debug_out.append(f"Elim ({-alpha})*R({r}) + R({r_prime})")
        r += 1
        c += 1
    P = AlgoMatrix(pmat)
    L = AlgoMatrix([[1 if r==c else (grid[r][c] if r &gt; c else 0) for c in range(n)] for r in range(m)])
    U = AlgoMatrix([[grid[r][c] if r &lt;= c else 0 for c in range(n)] for r in range(m)])
    if debug: print("\n".join(debug_out))
    return P,L,U
</code></pre></div>
<figcaption><span class="type">Listing</span><span class="space"> </span><span class="codenumber">5.3.7<span class="period">.</span></span><span class="space"> </span>An implementation of the <span class="process-math">\(PA=LU\)</span> algorithm using partial pivoting.</figcaption></figure><span class="incontext"><a href="sec-matapps-ludecomp.html#listing-15" class="internal">in-context</a></span>
</body>
</html>
