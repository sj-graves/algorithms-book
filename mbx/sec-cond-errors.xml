<section xml:id="sec-Conditionals-Errors">
    <title>Errors, error handling, and the try statement</title>
    <!--<p>
        There are several ways that executing a program can go wrong. The best type of error is a <em>syntax error</em>, usually caused by a typo in your code. These won't even run, and IDLE is very good at detecting them. The second best type of error is an <em>exception</em>. Exceptions are errors which are <c>raise</c>d by doing something which is syntactically correct in code but violates something about the way Python works. Here's a simple demonstration <mdash /> you can't add a string and an integer.
    </p>
    <pre>
        >>> s='123'
        >>> t=4
        >>> s+t
        Traceback (most recent call last):
        File "&lt;pyshell#23>", line 1, in &lt;module>
        s+t
        TypeError: Can't convert 'int' object to str implicitly
        >>> t+s
        Traceback (most recent call last):
        File "&lt;pyshell#24>", line 1, in &lt;module>
        t+s
        TypeError: unsupported operand type(s) for +: 'int' and 'str'
    </pre>-->
    <subsection xml:id="sec-Conditionals-Errors-SyntaxErrors">
        <title>Syntax errors</title>
        <p>
            There are many ways in which the execution of a program can go wrong, and we call these <em>errors.</em> The first type is the <em>syntax error</em>, which is the equivalent of using bad grammar in English. For instance, the words <q>Grandma what this food</q> do not form a meaningful sentence because there is no verb. A syntax error is code which as written is meaningless to the interpreter. As an example, try the following.
        </p>
        <sage>
            <input>
                foo = 2^
            </input>
        </sage>
        <p>
            In this case, a syntax error arises because the <c>^</c> operator is a binary operator but we have only supplied one operand, the integer 2. Syntax errors are easy for Sage to detect and generally easy to fix; once you've learned how to program, syntax errors tend to disappear except when learning a new programming language or due to typos in your code.
        </p>
    </subsection>
    
    <subsection xml:id="sec-Conditionals-Errors-Exceptions">
        <title>Exceptions</title>
        <p>
            The next class of errors is also easy to detect by Sage and are called <em>exceptions</em>. In both Sage and Python, <c>Exception</c> is a special data type used for all sorts of errors which arise during programming. The terminology used by programmers is that a syntactically correct operation which disagrees with the rules for a particular object will <em>raise</em> an exception, which either must be <em>handled</em> or interrupt the execution of the program. Since an unhandled exception will terminate execution and Sage provides some short <em>debugging information</em> when execution fails, you will quickly become proficient in writing exception handlers. Many of the errors you will see in your life as a programmer are exceptions: type errors, index errors, value errors, name errors, and zero-division errors are all common examples. Try the following sequence of code examples to see each of these in turn.
        </p>
        <sage>
            <input>
                foo = 5
                bar = 'This is a string.'
                print foo*bar
                print foo+bar
            </input>
        </sage>
        <sage>
            <input>
                foo = [2^i for i in range(10)]
                foo[11]
            </input>
        </sage>
        <sage>
            <input>
                bar = 'This is a string.'
                print int(bar)
            </input>
        </sage>
        <sage>
            <input>
                foobar = 'This is also a string.'
                print frobozz
            </input>
        </sage>
        <sage>
            <input>
                print 1/0
            </input>
        </sage>

        <p>
            As mentioned above, in order for an exception to occur and stop execution, it must be <em>raised</em>. As with many programming structures in Sage and Python, this is done intuitively, via a <c>raise</c> command.
        </p>
        <sage>
            <input>
                raise RuntimeError(&quot;This is where you put the error text.&quot;)
            </input>
        </sage>
    </subsection>
    <subsection xml:id="sec-Conditionals-Errors-ExceptionHandling">
        <title>Exception handling</title>
        <p>
            To correctly handle an exception, it must be raised within a special block structure called a <em>try-except</em> block. 
        </p>
        <sage>
            <input>
                n = 8
                try:
                    if n%3==0:
                        raise RuntimeError('This is a runtime error.')

                    elif n%3==1:
                        raise ValueError('This is a value error')

                    elif n%3==2:
                        raise TypeError('This is a type error.')

                    raise ZeroDivisionError('Not really zero division.')

                except RuntimeError:
                    print 'This string will print upon a raised RuntimeError.'

                except ValueError:
                    print 'This string will print upon a raised ValueError.'

                except:
                    print 'Any other type of exception will trigger this!'
                    raise

                print 'The exception is safely handled.'
            </input>
        </sage>
        <p>
            In the above Sage code, changing the initial value of <c>n</c> will cause varying types of exception to be raised. <c>RuntimeError</c> is a very convenient type of error to plan to raise as a <em>flow control technique</em>, which we will discuss at the end of this section. It is very important to note that Sage code which includes a <c>try:</c> statement must also contain a subsequent <c>except:</c> statement, or a <c>SyntaxError</c> will result. Any number of specific exception types can be handled prior to the final <q>catch all</q> <c>except:</c>. It is frequently useful to include a <c>raise</c> statement with no argument at the end of this final <c>except:</c> block in order to terminate execution by reraising whatever exception caused the fault in the first place.
        </p>
    </subsection>
    <subsection xml:id="sec-Conditionals-Errors-FlowControl">
        <title>Flow control</title>
        <note>
            <p>
                The examples in this subsection are purely for illustration. You need not use these commands for such trivial results.
            </p>
        </note>
        <p>
        Sometimes it is necessary to immediately interrupt the execution of a block of code inside a loop and continue to the next iteration. This functionality is provided in Sage using the <c>continue</c> command. 
        </p>
        <listing>
            <program>
                <input>
                    s = 0
                    for x in range(10):
                        if x%2==0:
                            continue
                        s += x
                    print s
                </input>
            </program>
            <caption>
                An example using the <c>continue</c> command. What do you expect to be the output?
            </caption>
        </listing>
        <p>
            On the other hand, it is sometimes necessary to immediately terminate an entire loop, regardless of what is the value of the conditional (for a while loop) or the index (for a for loop). This is performed via the <c>break</c> command.
        </p>
        <listing>
            <program>
                <input>
                    s = 0
                    for x in range(10):
                        if x%7==0:
                            break
                    s += x
                    print s
                </input>
            </program>
            <caption>
                An example using the <c>break</c> command. What do you expect to be the output?
            </caption>
        </listing>
        <p>
            Combining <c>continue</c> and <c>break</c> commands with good exception handling provides a very high degree of control over the flow of a program. Remember: intentionally raising an exception outside of a <c>try:... except:...</c> block is a sort of <q>nuclear option,</q> as it will immediately terminate the execution of the program <em>no matter what</em>.
        </p>
    </subsection>
    <example>
        <title>Exception handling in vital systems engineering</title>
        <p>
            In various types of engineering, there are varying degrees of tolerance of faults. For instance, it is much less damaging if a outside house faucet is leaking than if the hydraulic line controlling an airplane's elevon or aileron fails. In <em>vital systems engineering</em> it is required that when any failure occurs, the system must fail into a controlled state. Exception handling in this case is critical -- an example with which most Americans are familiar is the software controlling a traffic light. For many failures of the control software, the <q>controlled failure state</q> is to revert to a flashing red light in all directions. Traffic law provides that this is to be treated as an all-direction stop sign. In fact, traffic law also provides the final failure state: if the power goes out altogether and the light is off, drivers are required to treat the light as a stop sign.
        </p>
    </example>
    <!--<p>
        How these errors occurs is actually built in to the definitions of type <c>int</c> and type <c>str</c>. Somewhere in the <c>builtin</c> code for these types, a command reading <c>raise(TypeError('...'))</c> occurs. The <em>exception</em> is a <em>type error</em>, where you are trying to combine data types which are incompatible. There are lots of predefined exceptions: <c>TypeError</c>, <c>ValueError</c>, and <c>NameError</c> are the three you will most commonly see, followed by <c>ZeroDivisionError</c> when you aren't careful in your programming.
    </p>

    <p>
        In <c>les3_ex3.py</c>, I used the <c>ValueError</c> which is raised by trying to force the conversion of a non-integer string to an integer. Python is able to correctly handle the conversion of a string like <c>'12345'</c> to an integer, but to ask <q>what is the integer form of <c>'abc'</c>?</q> is a meaningless question. The <c>try: ... except: ...</c> block is a very specialized type of <c>if...then</c> structure. Python will run the code inside a <c>try:</c> block, and if an error is <c>raise</c>d will jump to the first <c>except... :</c> statement. If the type of the exception matches, that block will execute. The final block of <c>les3_ex3.py</c> is
    </p>
    <pre>
        except:
            raise
    </pre>
    <p>
        which terminates the <c>try:... except:...</c> structure by <em>re-raising any unhandled exception</em>. This allows you to press Ctrl-C to exit the <c>while True:</c> loop, for instance. This is also the behavior of the <c>break</c> command: it makes the program immediately exit the innermost enclosing loop.
    </p>

    <p>
        The raising and handling of exceptions is often treated as an advanced programming topic, but is a useful tool even at the introductory level to help understand how programming errors are made, and how to avoid or mitigate them.
    </p>-->
    <p>
        One last flow control command to acknowledge is the <c>pass</c> command. Everything after a <c>pass</c> statement in the current block is ignored; mostly these are used while in the early stages of writing code, to provide a place holder for a section which has not been written.
    </p>
    <sage>
        <input>
            n = 4
            if n % 3 == 1:
                pass
            else:
                print 'The value of n is not one more than a multiple of three.'
        </input>
    </sage>
</section>
