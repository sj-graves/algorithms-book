<section xml:id="sec-Conditionals-Errors">
    <title>Exceptions and exception handling</title>
    <subsection xml:id="sec-Conditionals-Errors-SyntaxErrors">
        <title>Syntax errors</title>
        <p>
            There are many ways in which the execution of a program can go wrong, and we call these <em>errors.</em> The first type is the <em>syntax error</em>, which is the equivalent of using bad grammar in English. For instance, the words <q>Grandma what this food</q> do not form a meaningful sentence because there is no verb. A syntax error is code which as written is meaningless to the interpreter. As an example, try the following.
        </p>
        <sage>
            <input>
                foo = 2^
            </input>
        </sage>
        <p>
            In this case, a syntax error arises because the <c>^</c> operator is a binary operator but we have only supplied one operand, the integer 2. Syntax errors are easy for Sage to detect and generally easy to fix; once you've learned how to program, syntax errors tend to disappear except when learning a new programming language or due to typos in your code.
        </p>
    </subsection>
    
    <subsection xml:id="sec-Conditionals-Errors-Exceptions">
        <title>Exceptions</title>
        <p>
            The next class of errors is also easy to detect by Sage and are called <em>exceptions</em>. In both Sage and Python, <c>Exception</c> is a special data type used for all sorts of errors which arise during programming. The terminology used by programmers is that a syntactically correct operation which disagrees with the rules for a particular object will <em>raise</em> an exception, which either must be <em>handled</em> or interrupt the execution of the program. Since an unhandled exception will terminate execution and Sage provides some short <em>debugging information</em> when execution fails, you will quickly become proficient in writing exception handlers. Many of the errors you will see in your life as a programmer are exceptions: type errors, index errors, value errors, name errors, and zero-division errors are all common examples. Try the following sequence of code examples to see each of these in turn.
        </p>
        <sage>
            <input>
                foo = 5
                bar = 'This is a string.'
                print foo*bar
                print foo+bar
            </input>
        </sage>
        <sage>
            <input>
                foo = [2^i for i in range(10)]
                foo[11]
            </input>
        </sage>
        <sage>
            <input>
                bar = 'This is a string.'
                print int(bar)
            </input>
        </sage>
        <sage>
            <input>
                foobar = 'This is also a string.'
                print frobozz
            </input>
        </sage>
        <sage>
            <input>
                print 1/0
            </input>
        </sage>

        <p>
            As mentioned above, in order for an exception to occur and stop execution, it must be <em>raised</em>. As with many programming structures in Sage and Python, this is done intuitively, via a <c>raise</c> command.
        </p>
        <sage>
            <input>
                raise RuntimeError(&quot;This is where you put the error text.&quot;)
            </input>
        </sage>
    </subsection>
    <subsection xml:id="sec-Conditionals-Errors-ExceptionHandling">
        <title>Exception handling</title>
        <p>
            To correctly handle an exception, it must be raised within a special block structure called a <em>try-except</em> block. 
        </p>
        <sage>
            <input>
                n = 8
                try:
                    if n%3==0:
                        raise RuntimeError('This is a runtime error.')

                    elif n%3==1:
                        raise ValueError('This is a value error')

                    elif n%3==2:
                        raise TypeError('This is a type error.')

                    raise ZeroDivisionError('Not really zero division.')

                except RuntimeError:
                    print 'This string will print upon a raised RuntimeError.'

                except ValueError:
                    print 'This string will print upon a raised ValueError.'

                except:
                    print 'Any other type of exception will trigger this!'
                    raise

                print 'The exception is safely handled.'
            </input>
        </sage>
        <p>
            In the above Sage code, changing the initial value of <c>n</c> will cause varying types of exception to be raised. <c>RuntimeError</c> is a very convenient type of error to plan to raise as a <em>flow control technique</em>, which we will discuss at the end of this section. It is very important to note that Sage code which includes a <c>try:</c> statement must also contain a subsequent <c>except:</c> statement, or a <c>SyntaxError</c> will result. Any number of specific exception types can be handled prior to the final <q>catch all</q> <c>except:</c>. It is frequently useful to include a <c>raise</c> statement with no argument at the end of this final <c>except:</c> block in order to terminate execution by reraising whatever exception caused the fault in the first place.
        </p>
    </subsection>
    <subsection xml:id="sec-Conditionals-Errors-FlowControl">
        <title>Flow control</title>
        <note>
            <p>
                The examples in this subsection are purely for illustration. You need not use these commands for such trivial results.
            </p>
        </note>
        <p>
        Sometimes it is necessary to immediately interrupt the execution of a block of code inside a loop and continue to the next iteration. This functionality is provided in Sage using the <c>continue</c> command. 
        </p>
        <listing>
            <program>
                <input>
                    s = 0
                    for x in range(10):
                        if x%2==0:
                            continue
                        s += x
                    print s
                </input>
            </program>
            <caption>
                An example using the <c>continue</c> command. What do you expect to be the output?
            </caption>
        </listing>
        <p>
            On the other hand, it is sometimes necessary to immediately terminate an entire loop, regardless of what is the value of the conditional (for a while loop) or the index (for a for loop). This is performed via the <c>break</c> command.
        </p>
        <listing>
            <program>
                <input>
                    s = 0
                    for x in range(10):
                        if x%7==0:
                            break
                    s += x
                    print s
                </input>
            </program>
            <caption>
                An example using the <c>break</c> command. What do you expect to be the output?
            </caption>
        </listing>
        <p>
            Combining <c>continue</c> and <c>break</c> commands with good exception handling provides a very high degree of control over the flow of a program. Remember: intentionally raising an exception outside of a <c>try:... except:...</c> block is a sort of <q>nuclear option,</q> as it will immediately terminate the execution of the program <em>no matter what</em>.
        </p>

        <example>
            <title>Exception handling in vital systems engineering</title>
            <p>
                In various types of engineering, there are varying degrees of tolerance of faults. For instance, it is much less damaging if a outside house faucet is leaking than if the hydraulic line controlling an airplane's elevon or aileron fails. In <em>vital systems engineering</em> it is required that when any failure occurs, the system must fail into a controlled state. Exception handling in this case is critical -- an example with which most Americans are familiar is the software controlling a traffic light. For many failures of the control software, the <q>controlled failure state</q> is to revert to a flashing red light in all directions. Traffic law provides that this is to be treated as an all-direction stop sign. In fact, traffic law also provides the final failure state: if the power goes out altogether and the light is off, drivers are required to treat the light as a stop sign.
            </p>
        </example>
        
        <p>
            One last flow control command to acknowledge is the <c>pass</c> command. Everything after a <c>pass</c> statement in the current block is ignored; mostly these are used while in the early stages of writing code, to provide a place holder for a section which has not been written.
        </p>
        <sage>
            <input>
                n = 4
                if n % 3 == 1:
                    pass
                else:
                    print 'The value of n is not one more than a multiple of three.'
            </input>
        </sage>
    </subsection>

    <subsection xml:id="sec-Conditionals-Errors-Bugs">
        <title>Bugs</title>
        <p>
            The final and worst type of programming error is not automatically detectable: the <em>bug</em>. Bugs are errors in your algorithm which do not violate any rules for the language, but nonetheless lead to incorrect results or responses in executing the program. Bugs are nearly unavoidable and often are diabolically difficult to diagnose, isolate, and solve. The process of doing these three tasks is <em>debugging</em>, and often one of the hardest tasks for a programmer is to debug code written by someone else. For this reason, we come now to an important programming maxim.
        </p>
        <principle> 
            <statement>
                <p>
                    Always <em>document your code</em>.
                </p>
            </statement>
        </principle>
        <p>
            <em>Documenting your code</em> is the process of including instructive comments about the iuntended flow of the program in the code itself. Short comments in Sage are lines of code beginning with the <em>hash</em> symbol <c>#</c>. Longer comments are included as multiline strings, beginning and ending with tripled quotes, either <c>'''</c> or <c>&quot;&quot;&quot;</c>.
        </p>
        <sage>
            <input>
                print 'This code executes.'
                # This is a short comment and nothing on this line executes
                print 'This code also executes.'
                &quot;&quot;&quot;This is 
                a longer
                comment.&quot;&quot;&quot;
                print 'Here\'s a last line which executes.'
            </input>
        </sage>
        <p>
            It is a bad habit of programmers to not provide extensive documentation to their code. The assumption that another programmer will need to read code later is deeply flawed, but it is often the case that after a significant time interval the original programmer will have little or no understanding of how their code works. While writing extensive comments is fairly boring, it saves time in the long run when code must be reused.
        </p>
    </subsection>
</section>
