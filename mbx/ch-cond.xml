<chapter xmlns:xi="http://www.w3.org/2001/XInclude" xml:id="ch-Conditionals">
    <title>Sage: Conditioning and error handling</title>

    <objectives>
        <ol type="1">
            <li><p>Define the <c>bool</c> data type.</p></li>
            <li><p>Discuss conditional statements.</p></li>
            <li><p>Discuss error handling via <c>try:... except:...</c> blocks.</p></li>
        </ol>
    </objectives>
    
    <introduction>
        <p>
        A computer program which only performs the same task with no changes regardles of input is quite limited; what if, for instance, the input doesn't make sense? Sometimes Sage will handle "strange" input in a consistent manner, although it is unexpected. Here's an example: let's set <c>n</c> to a negative integer and try to list the integers in the range <m>[n,0]</m>.
        </p>
        <sage>
        <input>
            n = -5
            for x in range(n):
                print x,
            </input></sage>
        <p>
        This is actually correct behavior inherited from Python: remember that <c>range(n)</c> lists the nonnegative integers <m>0, 1, 2, \ldots, n-1</m>. Since we specified <c>n</c> to be negative, the correct range of integers to return is empty. In order to change the behavior depending upon the type of input, we need to be able to evaluate whether a statement is True or False.<fn>Stephen Colbert refers to this as "truthiness."</fn> We will revisit this example later.</p>
    </introduction>
    
    <xi:include  href="sec-cond-booleans.xml" />
    <xi:include  href="sec-cond-conditionals.xml" />
    <xi:include  href="sec-cond-errors.xml" />
    <xi:include  href="sec-cond-breakpass.xml" />
</chapter>
