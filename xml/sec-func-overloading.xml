<section xml:id="sec-Functions-Overloading">
    <title>Operator overloading</title>

    <introduction>
        <p>
            We learn in elementary school that the procedure necessary to calculate <m>3 + 5</m> and the procedure necessary to calculate <m>\frac13 + \frac15</m> are different, but we never have difficulty connecting that both procedures are addition. Computers, however, are much simpler and in order for a computer to <q>recognize</q> that the two operations are related it must be told explicitly. The method of instructing a computer than integer addition and fraction addition may use the same symbol is called <em>operator overloading</em>.
        </p>
        <p>
            In fact, the function names for standard arithmetic operators are similar to the initialization method: they all look like <c>__method__</c>.  The difficulty shows up when we recognize that Sage's addition operator is not commutative
            <fn>
                Recall that an operation <m>\star</m>is <em>commutative</em> if and only if <m>a\star b=b\star a</m> for every pair <m>(a,b)</m> in the domain of the operator. The first time students usually encounter a non-commutative operation is in matrix theory, since matrix multiplication is the canonical example of a non-commutative operation.
            </fn>
            in every case. For instance, consider addition of strings.
        </p>
        <sage>
            <input>
                foo = 'This is a first string'
                bar = 'And this is another'
                print foo + bar
                print bar + foo
            </input>
        </sage>
        <p>
            The two operators for which commutativity is an issue are addition and multiplication, and the <q>problem</q> of deciding whether or not they should be commutative is determined within the class definition. The following table summarizes the <q>handedness</q> of the listed operators, along with the method names for inclusion in class definitions.
        </p>
        <table>
            <tabular>
                <row bottom="major">
                    <cell>Method</cell>
                    <cell>Operation Defined</cell>
                </row>
                <row>
                    <cell>
                        <c>__add__(self, other)</c>
                    </cell>
                    <cell>
                        <c>self + other</c>
                    </cell>
                </row>
                <row>
                    <cell>
                        <c>__radd__(self, other)</c>
                    </cell>
                    <cell>
                        <c>other + self</c>
                    </cell>
                </row>
                <row>
                    <cell>
                        <c>__mul__(self, other)</c>
                    </cell>
                    <cell>
                        <c>self * other</c>
                    </cell>
                </row>
                <row>
                    <cell>
                        <c>__rmul__(self, other)</c>
                    </cell>
                    <cell>
                        <c>other * self</c>
                    </cell>
                </row>
            </tabular>
        </table>
        <p>
            The first step in implementing the operations of addition and multiplication for Gaussian integers is to clearly articulate the algorithms. We should probably state a definition.
        </p>
        <definition>
            <statement>
                <p>
                    An <em>algorithm</em> is a formal procedure which gives the necessary instructions to complete a task, often computational.
                </p>
            </statement>
        </definition>
        <p>
            This is a very loose definition, because a lot of procedures are algorithms, although we don't think of them in such terms: a recipe is an algorithm for producing food, after all. We will restrict our use of the terminology to procedures which enumerate the steps of some sort of computational task.
        </p>

    </introduction>
    <subsection xml:id='sec-Functions-Overloading-ComplexOperations'>
        <title>Operating on the Gaussian integers</title>
        <subsubsection>
            <title>Complex addition</title>
            <p>
                Since we have decided that every real number can be written as a complex number with imaginary part <m>0</m>, it must be that whatever we define to be the addition operator in the complex numbers must respect real addition. In fact, if we treat <m>i</m> like a real variable rather than an imaginary constant, we get the desired definition from the distributive property. Suppose <m>z_1=x_1+iy_1</m> and <m>z_2=x_2+iy_2</m> are complex numbers. Then
            </p>
            <md>
                <mrow> z_1 + z_2 = </mrow>
            </md>
        </subsubsection>
    </subsection>
</section>
<!--
<introduction>
<p>
Operator overloading is easy for a human and hard for a computer. A person can immediately see the symbol <c>+</c> and know from the context how to interpret it. For instance, we can immediately understand that there is a difference between ``<m>3+5</m>" and ``Alice + Bob." A computer has to be told how to handle each of them separately! This is handled by <em>overloading</em> the operator of <c>+</c>. Python does this behind the curtain. Every data type for which <c>+</c> makes sense must have in its class definition a method called <c>__add__</c>. In fact, usually it is implemented as <c>def __add__(self, other):</c>, and then the return value is <c>self + other</c>. It is generally also smart to define a <c>__radd__</c> method to return <c>other + self</c>, and for numerical quantities they should be equal<fn>Addition is almost universally a commutative operation.</fn>.
</p>
</introduction>


<subsection>
<title>Complex addition</title>
<p>
What is the algorithm for complex addition? That is, if I defined <m>x=a+ib</m> and <m>y=c+id</m> for some <m>a,b,c,d\in\mathbb{R}</m>, what does it mean to write <m>x+y</m>? If we treat <m>x=a+ib</m> and <m>y=c+id</m> as polynomials in variable <m>i</m> with real coefficients, we can use the rules for polynomials and obtain
<md>
  <mrow>  x + y \amp  = (a+ib) + (c+id)</mrow>
  <mrow>  \amp = a+c+ib+id</mrow>
  <mrow>  \amp =(a+c) + i(b+d).</mrow>
</md>
</p>

<p>
Since it makes sense for complex numbers and real numbers to follow the same rules, this is a sensible definition for the algorithm of addition.
</p>
<algorithm>
<p>
(Complex Addition)
Let <c>x</c> be a <c>ComplexNumber</c> with representation <c>(a,b)</c> and let <c>y</c> be some other variable.
<ol>
<li><p>If <c>y</c> is a <c>ComplexNumber</c> with representation <c>(c,d)</c>, return 
 <c>ComplexNumber(a + c, b + d)</c>.</p></li>
<li><p>If not, but <c>y</c> is either an <c>int</c> or a <c>float</c>, return 
 <c>ComplexNumber(a + y, b)</c>.</p></li>
<li><p>Otherwise, raise a <c>TypeError</c>.</p></li>
</ol>

</p>
</algorithm>
<p>
For complex numbers, we update <c>les4_ex2.py</c> as follows to implement addition and right addition.
</p>
<pre>
from math import sqrt

class ComplexNumber:
    ...
    def __add__(self,other):
        if type(other)==type(self):
            return ComplexNumber(self.real_part + other.re(),
                                 self.imag_part + other.im())
        elif type(other) in [type(1), type(0.1)]:
            return ComplexNumber(other + self.real_part, self.imag_part)

    def __radd__(self, other):
        return self.__add__(other)
</pre>
</subsection>


<subsection>
<title>Complex Multiplication</title>
<p>
Complex multiplication, like complex addition, follows naturally from the behavior of polynomials with real coefficients. Again letting <m>x=a+ib</m> and <m>y=c+id</m> be complex numbers, we see that
<md>
  <mrow>  xy \amp = (a+ib)(c+id)</mrow>
  <mrow>  \amp = ac +ibc +iad + i^2bd</mrow>
  <mrow>  \amp = (ac-bd)+i(bc+ad).</mrow>
</md>
</p>

<p>
If it so happens that <m>d=0</m>, then <m>xy = ac+ibc</m>. Again, we can use this to determine the algorithm for complex multiplication.
</p>
<algorithm>
<p>
(Complex Multiplication) Let <c>x</c> be a <c>ComplexNumber</c> with representation <c>(a,b)</c> and let <c>y</c> be some other variable.
<ol>
<li><p>If <c>y</c> is a <c>ComplexNumber</c>, return 

 <c>ComplexNumber(a * c - b * d, a * d + b * c)</c></p></li>
<li><p>If not, but <c>y</c> is either an <c>int</c> or a <c>float</c>, return

 <c>ComplexNumber(a*y, b*y)</c></p></li>
<li><p>Otherwise, raise a <c>TypeError</c>.</p></li>
</ol>

</p>
</algorithm>
<p>
To implement this is similar to the implementation of addition: there are builtin operators for both left and right multiplication (which is important since multiplication is often not commutative) which can be overloaded, named <c>__mul__</c> and <c>__rmul__</c>. Including them, here is the final, full version of <c>les4_ex2.py</c>.
</p>
<pre>
from math import sqrt

class ComplexNumber:
    """A complex number class.
    """
    def __init__(self,a,b):
        if not (type(a) in [type(0), type(0.1)] and
                type(b) in [type(0), type(0.1)]):
            raise TypeError("ComplexNumber(a,b) expects a and b to both be of"\
                            + " type 'int' or type 'float'.")
        else:
            self.real_part = a
            self.imag_part = b

    def __repr__(self):
        return str( (self.real_part, self.imag_part) )

    def __str__(self):
        (a, b) = (self.real_part, self.imag_part)
        if a != 0:
            s = str(a)
            if b&lt;0:
                s += ' - I*(' + str(-b) + ')'
            elif b>0:
                s += ' + I*(' + str(b) + ')'
        else:
            if b&lt;0:
                s = '-I*(' + str(b) + ')'
            else:
                s = 'I*(' + str(b) + ')'
        return s

    def norm(self):
        return sqrt(self.real_part**2 + self.imag_part**2)

    def re(self):
        return self.real_part

    def im(self):
        return self.imag_part

    def __add__(self,other):
        (a, b) = (self.real_part, self.img_part)
        if type(other)==type(self):
            (c, d) = (other.re(), other.im())
            return ComplexNumber(a + c, b + d)
        elif type(other) in [type(1), type(0.1)]:
            return ComplexNumber(other + a, b)
        else:
            raise TypeError("No method is defined for addition of "\
                            + "ComplexNumber + '" \
                            + other.__class__().__name__() + "'")

    def __radd__(self, other):
        return self.__add__(other)

    def __mul__(self, other):
        (a, b) = (self.real_part, self.imag_part)
        if type(other)==type(self):
            (c, d) = (other.re(), other.im())
            return ComplexNumber(a * c - b * d, a * d + b * c)
        elif type(other) in [type(0), type(0.1)]:
            return ComplexNumber(a * other, b * other)
        else:
            raise TypeError("No method is defined for addition of "\
                            + "ComplexNumber + '" \
                            + other.__class__().__name__() + "'")

    def __rmul__(self, other):
        return self.__mul__(other)
</pre>
</subsection>


<subsection>
<title>Overloading other operators</title>
<p>
There are many, many operators and methods which you will want to overload to make robust classes. In fact, almost everything can be overloaded if you can determine how Python handles an operator behind the scenes. For numerical data types, there's an easy way to see what the ``normal" operators are: type <c>help(float)</c> and read the documentation for the <c>float</c> class! In fact, you can often inherit methods from ``parent" classes if the operations are already correct.
</p>
</subsection>


<subsection>
<title>``It's a trap!"</title>
<p>
In fact, we didn't need to do any of this work to implement complex numbers. Try <c>help(complex)</c>. Following a convention from engineering and the sciences, <m>j=\sqrt{-1}</m>, and entering <c>z = 5_3j</c> produces a complex number with full functionality. We won't be saving our <c>ComplexNumber</c> class for further use.
</p>

<p>
\part{Matrix algorithms}
</p>
</subsection>
</section>-->

