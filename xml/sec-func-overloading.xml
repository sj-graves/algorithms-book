<section xml:id="sec-Functions-Overloading">
    <title>Operator overloading</title>

    <introduction>
        <p>
            We learn in elementary school that the procedure necessary to calculate <m>3 + 5</m> and the procedure necessary to calculate <m>\frac13 + \frac15</m> are different, but we never have difficulty connecting that both procedures are addition. Computers, however, are much simpler and in order for a computer to <q>recognize</q> that the two operations are related it must be told explicitly. The method of instructing a computer than integer addition and fraction addition may use the same symbol is called <em>operator overloading</em>.
        </p>
        <p>
            In fact, the function names for standard arithmetic operators are similar to the initialization method: they all look like <c>__method__</c>.  The difficulty shows up when we recognize that Sage's addition operator is not commutative
            <fn>
                Recall that an operation <m>\star</m>is <em>commutative</em> if and only if <m>a\star b=b\star a</m> for every pair <m>(a,b)</m> in the domain of the operator. The first time students usually encounter a non-commutative operation is in matrix theory, since matrix multiplication is the canonical example of a non-commutative operation.
            </fn>
            in every case. For instance, consider addition of strings.
        </p>
        <sage>
            <input>
                foo = 'This is a first string'
                bar = 'And this is another'
                print foo + bar
                print bar + foo
            </input>
        </sage>
        <p>
            The two operators for which commutativity is an issue are addition and multiplication, and the <q>problem</q> of deciding whether or not they should be commutative is determined within the class definition. The following table summarizes the <q>handedness</q> of the listed operators, along with the method names for inclusion in class definitions.
        </p>
        <table>
            <tabular>
                <row bottom="major">
                    <cell>Method</cell>
                    <cell>Operation Defined</cell>
                </row>
                <row>
                    <cell>
                        <c>__add__(self, other)</c>
                    </cell>
                    <cell>
                        <c>self + other</c>
                    </cell>
                </row>
                <row>
                    <cell>
                        <c>__radd__(self, other)</c>
                    </cell>
                    <cell>
                        <c>other + self</c>
                    </cell>
                </row>
                <row>
                    <cell>
                        <c>__mul__(self, other)</c>
                    </cell>
                    <cell>
                        <c>self * other</c>
                    </cell>
                </row>
                <row>
                    <cell>
                        <c>__rmul__(self, other)</c>
                    </cell>
                    <cell>
                        <c>other * self</c>
                    </cell>
                </row>
            </tabular>
        </table>
        <p>
            The first step in implementing the operations of addition and multiplication for Gaussian integers is to clearly articulate the algorithms. We should probably state a definition.
        </p>
        <definition>
            <statement>
                <p>
                    An <em>algorithm</em> is a formal procedure which gives the necessary instructions to complete a task, often computational.
                </p>
            </statement>
        </definition>
        <p>
            This is a very loose definition, because a lot of procedures are algorithms, although we don't think of them in such terms: a recipe is an algorithm for producing food, after all. We will restrict our use of the terminology to procedures which enumerate the steps of some sort of computational task.
        </p>

    </introduction>
    <subsection xml:id='sec-Functions-Overloading-ComplexOperations'>
        <title>Operating on the Gaussian integers</title>
        <subsubsection>
            <title>Complex addition</title>
            <p>
                Since we have decided that every real number can be written as a complex number with imaginary part <m>0</m>, it must be that whatever we define to be the addition operator in the complex numbers must respect real addition. In fact, if we treat <m>i</m> like a real variable rather than an imaginary constant, we get the desired definition from the distributive property. Suppose <m>z_1=x_1+iy_1</m> and <m>z_2=x_2+iy_2</m> are complex numbers. Then
            </p>
            <md align='gather'>
                <mrow> z_1 + z_2 &amp;= (x_1 + iy_1) + (x_2 + iy_2) </mrow>
                <mrow> &amp;= (x_1+x_2) + i(y_1+y_2) </mrow>
            </md>
            <p>
                This turns into an algorithm very nicely, but what if one of <m>z_1</m> or <m>z_2</m> is of the wrong data type in Sage? Specifically, we want to be able to seamlessly add a Sage <c>Integer</c> to a <c>GaussianInteger</c> and have it return the correct <c>GaussianInteger</c>. This requires that we include a little type checking into our algorithm.
            </p>
            <algorithm>
                <title>Addition for Gaussian integers</title>
                <statement>
                    <p>
                        Suppose <c>self</c> is a <c>GaussianInteger</c> and <c>other</c> is some other input value.
                    </p>
                    <ol>
                        <li> 
                            If <c>other</c> and <c>self</c> have the same type, <c>GaussianInteger</c>, return a new <c>GaussianInteger</c> with real part <c>self.re()+other.re()</c> and imaginary part <c>self.im()+other.im()</c>.
                        </li>
                        <li>
                            Otherwise, if <c>other</c> has type <c>Integer</c>, return a new <c>GaussianInteger</c> with real part <c>self.re()+other</c> and imaginary part <c>self.im()</c>.
                        </li>
                        <li>
                            Otherwise raise an error.
                        </li>
                    </ol>
                </statement>
            </algorithm>
            <p>
                Now that we have an algorithm written down, writing the code is very direct. This is a virtue of using a Python-based language. In fact, we can do both left and right addition at the same time, since we know that addition of Gaussian integers is commutative.
            </p>
            <exercise>
                <title>Implement addition for the Gaussian integer class</title>
                <statement>
                    Try implementing the algorithm above in the <c>__add__</c> and <c>__radd__</c> methods of <c>GaussianInteger</c>.
                </statement>
                <solution>
                    <listing>
                        <program>
                            <input>
                                class GaussianInteger:

                                    ...

                                    def __add__(self, other):
                                        if type(other)==type(self):
                                            return GaussianInteger(self.re()+other.re(),self.im()+other.im())
                                        elif type(other)==type(1):
                                            return GaussianInteger(self.re()+other, self.im())
                                        else:
                                            typeOther = str(type(other))
                                            raise TypeError('Addition is not defined for ' + \
                                                'GaussianInteger and ' + typeOther)

                                    def __radd__(self, other):
                                        return self+other
                            </input>
                        </program>
                        <caption>The addition methods <c>__add__</c> and <c>__radd__</c> for class <c>GaussianInteger</c>.</caption>
                    </listing>
                    <p>
                        Since <c>__radd__(self,other)</c> is the method called by <c>other + self</c> and addition of complex numbers is commutative, we have introduced fewer potential errors by allowing <c>__radd__</c> to simply return the value of <c>self + other</c>. It is often beneficial to think of ways that the same functions can be reused rather than rewriting the same algorithm multiple times.
                    </p>
                </solution>
            </exercise>
            
        </subsubsection>
        
        <subsubsection>
            <title>Complex multiplication</title>
            <p>
                Like with addition, we already know an algorithm (often called FOIL) for multiplying binomials; if we are treating <m>i</m> as a variable, we can use FOIL and then the distributive and associative properties to write the product of two Gaussian integers. Suppose <m>z_1=x_1+iy_1</m> and <m>z_2=x_2+iy_2</m> are complex numbers. Then
            <md align='gather'>
                <mrow> z_1z_2 &amp;= (x_1+i y_1)(x_2+i y_2) </mrow>
                <mrow> &amp;= x_1x_2+ix_1y_2+ix_2y_1+i^2y_1y_2 </mrow>
                <mrow> &amp;= (x_1x_2-y_1y_2)+i(x_1y_2+x_2y_1) </mrow>
            </md>
            </p>
            <p>
                Just like with addition, this is exactly what we want when both <c>self</c> and <c>other</c> are of type <c>GaussianInteger</c>, but what about when <c>other</c> is an <c>Integer</c>? Again, quickly adding some type verification makes for a complete and correct algorithm.
            </p>
            <algorithm>
                <title>Multiplication for Gaussian integers</title>
                <statement>
                    <p>
                        Suppose <c>self</c> is a <c>GaussianInteger</c> and <c>other</c> is some other input value.
                    </p>
                    <ol>
                        <li> 
                            If <c>other</c> and <c>self</c> have the same type, <c>GaussianInteger</c>, let <c>x = self.realpart</c>, <c>y = self.imagpart</c>, <c>a = other.re()</c>, and <c>b = other.im()</c>. Return a new <c>GaussianInteger</c> with real part <c>a*x-b*y</c> and imaginary part <c>a*y+b*x</c>.
                        </li>
                        <li>
                            On the other hand, if <c>other</c> has type <c>Integer</c>, return a new <c>GaussianInteger</c> with real part <c>other*self.realpart</c> and imaginary part <c>other*self.imagpart</c>.
                        </li>
                        <li>
                            Otherwise raise an error.
                        </li>
                    </ol>
                </statement>                        
            </algorithm>
            <p>
                We again are working with an operation which is commutative, so the implementation of <c>__rmul__</c> can be written as a direct call to <c>__mul__</c>.
            </p>
            <exercise>
                <title>Implement multiplication for the Gaussian integer class</title>
                <statement>
                    Try implementing the above algorithm in the <c>__mul__</c> and <c>__rmul__</c> methods of the <c>GaussianInteger</c> class.
                </statement>
                <solution>
                    <listing>
                        <program>
                            <input>
                                class GaussianInteger:

                                    ...

                                    def __mul__(self, other):
                                        if type(other)==type(self):
                                            x, y = self.realpart, self.imagpart
                                            a, b = other.re(), other.im()
                                            return GaussianInteger(a*x-b*y, a*y+b*x)
                                        elif type(other)==type(1):
                                            return GaussianInteger(other*self.realpart, other*self.imagpart)
                                        else:
                                            typeOther = str(type(other))
                                            raise TypeError('Multiplication is not defined for ' + \
                                                'GaussianInteger and ' + typeOther)
                                
                                    def __rmul__(self,other):
                                        return self*other
                            </input>
                        </program>
                        <caption> The multiplication methods <c>__mul__</c> and <c>__rmul__</c> for the <c>GaussianInteger</c> class.</caption>
                    </listing>
                    <p>
                        Like in the previous exercise, we can avoid implementing the same algorithm twice for multiplication by returning <c>self * other</c> in the body of <c>__rmul__</c>.
                    </p>
                </solution>
            </exercise>
        </subsubsection>
    </subsection>
    
    <subsection>
        <title>Other operators to overload</title>
        <p>
            There are many, many operators and methods which you will want to overload to make robust classes. In fact, nearly every routine mathematical function can be overloaded <emdash /> you just need to know the <q>hidden</q> Python name of the operator. A good place to see a list of built-in methods which correspond to operators is in the <c>help</c> files for the <c>complex</c> class! Sage can natively handle complex numbers both as expressions (specified in the form <c>3-4*I</c>) or as a special <c>ComplexNumber</c> class (specified in the form <c>3-4j</c> where <m>j=\sqrt{-1}</m> as is the rule in engineering and the sciences).
        </p>
        <sage>
            <input>
                z = 3-4j
                print type(z)
                help(complex)
            </input>
        </sage>
        <exercise>
            <title>Implement other operators</title>
            <statement>
                <p>Try to write algorithms and implement operators for some other common mathematical operations: negation, subtraction, and integer powers are a good place to start.</p>
            </statement>
            <solution>
                <algorithm>
                    <title>Negation</title>
                    <statement>
                        <p>
                            If <c>self</c> is a <c>GaussianInteger</c>, return a new <c>GaussianInteger</c> with real part <c>-self.realpart</c> and imaginary part <c>-self.imagpart</c>.
                        </p>
                    </statement>
                </algorithm>
                <algorithm>
                    <title>Subtraction</title>
                    <statement>
                        <p>
                            Suppose <c>self</c> is a <c>GaussianInteger</c> and <c>other</c> is some other input value.
                        </p>
                        <ol>
                            <li> 
                                If <c>other</c> and <c>self</c> have the same type, <c>GaussianInteger</c>, or if <c>other</c> has type <c>Integer</c>, return <c>self + (-other)</c>.
                            </li>
                            <li>
                                Otherwise raise an error.
                            </li>
                        </ol>
                    </statement>
                </algorithm>
                <algorithm>
                    <title>Integer powers</title>
                    <statement>
                        <p>
                            Suppose <c>self</c> is a <c>GaussianInteger</c> and <c>other</c> is some other input value.
                        </p>
                        <ol>
                            <li>
                                If <c>other</c> has type <c>Integer</c>, let <c>value=GaussianInteger(1,0)</c>. Exactly <c>other</c> times, set <c>value = value*self</c>. Return <c>value</c>.
                            </li>
                            <li>
                                Otherwise raise an error.
                            </li>
                        </ol>
                    </statement>
                </algorithm>
            </solution>
        </exercise>
        <p>
            Since there is a built-in <c>ComplexNumber</c> class implemented as a mathematical ring in Sage, we don't need to keep our <c>GaussianInteger</c> class for further use; however, you'll want to keep it to use for the end of chapter project.
        </p>
    </subsection>
</section>
