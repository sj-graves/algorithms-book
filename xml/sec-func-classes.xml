<section xml:id="s-FP-CAM">
    <title>Classes, attributes, and methods</title>
    <introduction>
        <p>
            We already know about all sorts of different types of data. Now we want to be able to extend our list by defining our own data types. The philosophy of programming we'll follow is called the <term>object-oriented programming paradigm</term>. In this way of thinking, we start with the <term>class</term>. A class consists of all of the things of a particular kind: for instance, we have talked about the class of strings, or of lists. If we define <c>foo="this is a string"</c>we are declaring <c>foo</c>to be a particular object which is an <term>instance</term>of the string class. There is a set of <term>attributes</term>which is common to all objects in a class, and there are certain functions (called         <term>methods</term>) which can be applied to any object in a class. For instance, each human has an attribute which is their blood type and another attribute which is their birth year. An example of a method on a human object is to determine its age.
        </p>
        <p>
            It should be obvious that using <q>human</q>as a class and a particular human as an instance of the class is a silly example. Strings are much more sensible as an example, but they are a particularly limited and basic class. Let's consider a more complicated example.
        </p>
    </introduction>
    <subsection xml:id="ss-FP-CAM-GI">
        <title>Gaussian integers</title>
        <definition>
            <title>Gaussian integer</title>
            <statement>
                A <term>Gaussian integer</term>is a number of the form <m>a+i b</m>where both <m>a</m> and <m>b</m> are integers and <m>i</m> is the imaginary number such that <m>i^2 = -1</m>.
            </statement>
        </definition>
        <p>
            If we want to begin by building a class of Gaussian integers, we use the <c>class</c> block structure. As this is a named structure (like when we used <c>def</c> to define a function) we will want to provide a docstring so that we can get <c>help</c>on our class after we've defined it. Once a <c>class</c>is defined, an instance of the class is created by using the class name as a function.</p>
        <sage>
            <input>
                class g_int(): 
                    """A class of Gaussian integers. 
                    """

                g_int()
            </input>
            <output>
                &lt;__main__.g_int instance at 0x7f57fbcfdb48&gt;
            </output>
        </sage>
        <p>
            We have now created an instance of <c>g_int</c>, but it's not yet actually a Gaussian integer. Instead it's an <c>instance</c> of a do-nothing class. So we look at our definition and realize that in order to define a Gaussian integer, we must specify two integers. For a Gaussian integer <m>z=a+ib</m>, the integer <m>a</m> is the <term>real part of <m>z</m></term>and the integer <m>b</m>is the <term>imaginary part of <m>z</m></term>, so we will require that these be defined. In order to pass in particular values when we create our instance, we need to use the <c>__init__</c>method; a method is simply a function defined locally within a class, and there are a large number of special methods which are given        names beginning and ending with two underscores, <c>__</c>. We'll learn more about these in the next section. The <c>__init__</c>method is shorthand for <em>initialization</em>.
        </p>
        <listing>
            <program>
                <input>
                    class g_int():
                        """A class of Gaussian integers.
                        """

                        def __init__(self, a, b):
                            # g_int(a,b) will create a Gaussian integer a+i*b if a and b are integers
                            if type(a) == type(1) and type(b) == type(1):
                                self.realpart = a
                                self.imagpart = b
                            else:
                                raise TypeError('Must have integer arguments.')
                </input>
            </program>
        <caption>The beginning of a Gaussian integer class, with <c>__init__</c> method.</caption>
        </listing>
        <p>
            There is a strange first argument to our <c>__init__</c> method, named <c>self</c>. Since we are declaring an object, there needs to be a way for that object to know itself. This is roughly the equivalent of a person having an identity. In order to know whether you have anything in your pocket, you have to know to whom <q>you</q> and <q>your</q> refer. In Sage, <c>self</c> is the internal name of the object. Inside the code, we then refer to <c>self.realpart</c> and <c>self.imagpart</c>. These are the <term>attributes</term> of the object <c>self</c>, since every validly defined <c>g_int</c> will have a <c>.realpart</c> and a <c>.imagpart</c>. All this gives us a much more useable Gaussian integer class, but we still are missing something: we don't have a nice way to see what a particular <c>g_int</c> is! We know that if <c>foo</c> is an instance of <c>g_int</c>, then <c>foo.realpart</c> and <c>foo.imagpart</c> exist, but we want to print <c>foo</c> and have something that looks like <m>a+ib</m>! We add another special method, <c>__repr__</c>.
        </p>
        <listing>
            <program>
                <input>
                    class g_int():
                        ...
                        def __repr__(self):
                            out = str(self.realpart)
                            if self.imagpart &lt; 0:
                                out = out + "-i*({0})".format(-self.imagpart)
                            elif self.imagpart &gt; 0:
                                out = out + "+i*({0})".format(self.imagpart)
                            return out
                </input>
            </program>
            <caption> Adding a <c>__repr__</c> method to <c>class g_int</c>. The convention of using <c>...</c> implies that this listing is to be appended to the end of whatever previous definition of <c>class g_int</c> was given.
            </caption>
        </listing>
        
        <p>
            We have now added to special, predefined methods to our class of Gaussian integers, but how do we add other methods? Let's consider two functions of a Gaussian integer, the <term>norm</term> and the <term>conjugate</term>.
        </p>
        <definition>
            <title>Norms and conjugates of Gaussian integers</title>
            <statement>
                The <term>norm</term> of a Gaussian integer <m>a+ib</m> is the real number <m>\sqrt{a^2+b^2}</m>, and the <term>conjugate</term> of <m>a+ib</m> is <m>a-ib</m>.
            </statement>
        </definition>
        <p>
            We very simply add methods for these to our class, respectively naming the methods <c>norm</c> and <c>conj</c>.
        </p>
        <listing>
            <program>
                <input>
                    class g_int():
                        ...
                        def norm(self):
                            return sqrt(self.realpart^2 + self.imagpart^2)
                    
                        def conj(self):
                            return g_int(self.realpart, -self.imagpart)
                </input>
            </program>
            <caption>Adding <c>norm</c> and <c>conj</c> to the <c>g_int</c> class.</caption>
        </listing>
        <p>
            While this no means exhausts all the things we wish to be able to do with Gaussian integers, it's a beginning!
        </p>
    </subsection>
    <conclusion>
        <p>
            As we end of this section, hopefully you have created in CoCalc a worksheet to test all these commands. Your class definition should now look something like this.
        </p>
        <listing>
            <program>
                <input>
                    class g_int():
                        """A class of Gaussian integers.
                        """

                        def __init__(self, a, b):
                            # g_int(a,b) will create a Gaussian integer a+i*b if a and b are integers
                            if type(a) == type(1) and type(b) == type(1):
                                self.realpart = a
                                self.imagpart = b
                            else:
                                raise TypeError('Must have integer arguments.')

                        def __repr__(self):
                            out = str(self.realpart)
                            if self.imagpart &lt; 0:
                                out = out + "-i*({0})".format(-self.imagpart)
                            elif self.imagpart &gt; 0:
                                out = out + "+i*({0})".format(self.imagpart)
                            return out

                        def norm(self):
                            return sqrt(self.realpart^2 + self.imagpart^2)
                    
                        def conj(self):
                            return g_int(self.realpart, -self.imagpart)                    
                </input>
            </program>
            <caption> A currently-full listing of the class definition for the <c>g_int</c> Gaussian integer class.</caption>
        </listing>
    </conclusion>
    <!--         <definition>
            <statement>
                The <em>imaginary number <m>i</m></em> is defined to be the number which satisfies <m>i^2=-1</m>. A <em>complex number</em> is any number <m>z=a+ib</m> where <m>a</m> and <m>b</m> are real numbers. The real number <m>a</m> is the <em>real part of <m>z</m></em> and the real number <m>b</m> is the <em>imaginary part of <m>z</m></em>, and these are denoted by <m>\Real z=a</m> and <m>\Imag z=b.</m> A complex number <m>z</m> is a <em>Gaussian integer</em> if and only if <m>\Real z</m> and <m>\Imag z</m> are both integers.
            </statement>
        </definition>
        <p>
            Note that these definitions allow every real number to be considered as a complex number with the imaginary part equal to <m>0</m>; this in turn allows us to envision each imaginary number as a point on the <em>complex plane</em>, with horizontal axis the real part and vertical axis the imaginary part. All our basic operations on real numbers must naturally extend to operations on complex numbers, so however we define our class of complex numbers, we will need to define methods for addition, subtraction, multiplication, and exponentiation by integers; we will define these in the next section, <xref ref="sec-Functions-Overloading" autoname="title"/>. 
            <fn>
                We need not include a division operator, since a ratio of Gaussian integers certainly need not be a Gaussian integer.
            </fn>
            For each, we can double-check that our operation behaves correctly by testing against the built-in behavior of Sage on complex numbers. This code is not intended to be reused elsewhere (since Sage can already handle complex numbers) so it is safe to write it all in a worksheet.
        </p>
        <listing>
            <program>
                <input>
                    class GaussianInteger:
                        '''My Gaussian Integer class.
                        '''
                </input>
            </program>
            <caption>Beginning the Gaussian integer class. Notice that we should provide at least a brief docstring for class definitions.</caption>
        </listing>
        <p>
            Since we haven't provided anything other than a docstring for our class, the type of a variable declared to be an object of that class is just <c>'instance'</c>. Since we know that a complex number is totally determined by its real and imaginary parts, it makes sense that what we want to use to instantiate an actual complex number is something like <c>GaussianInteger(a,b)</c>. This is handled via the <em>initialization operator</em>, a special method defined within the class as the function <c>__init__</c>. We want to provide some input validation to our class, so we will define a method <c>__init__(self, a, b)</c> to verify that both <c>a</c> and <c>b</c> are integers. 
        </p>
        <listing xml:id="listing-Complex-init">
            <program>
                <input>
                    class GaussianInteger:
                        '''My Gaussian integer class.
                        '''
                        def __init__(self, a, b):
                            '''The two arguments to initialize the GaussianInteger class must be integers.
                            '''
                            if type(a)==type(1) and type(b)==type(1):
                                self.realpart = a
                                self.imagpart = b
                            else:
                                raise ValueError('Both arguments to GaussianInteger(a,b) must be integers.')
            
                </input>
            </program>
            <caption>The Gaussian integer class with an initialization method.</caption>
        </listing>
        <p>
            Out input validation consists of checking the type of the two arguments, <c>a</c> and <c>b</c>, against the type of the integer <m>1</m>. If either has a different type than that of <m>1</m>, a <c>ValueError</c> is raised. In the case where valid input is provided, we see that the <c>self</c> object is having two attributes assigned: <c>self.realpart</c> and <c>self.imagpart</c>.
        </p>
        <convention>
            <p>
                The strange method name of <c>__init__</c> is actually very important to the underlying Python source of Sage. Methods which are named according to the scheme <c>__method_name__</c> are generally the way that Python handles built-in <em>operators</em>, such as addition or subtraction. After all, to be able to have Sage interpret <c>4 + 5</c> it must know how to add one integer to another. We will discuss these operators at length in the next section, <xref ref="sec-Functions-Overloading" autoname="title"/>.
            </p>
            <p>
                The <c>__init__</c> method must assign a value to each attribute of an object, even if the value of the attribute is <c>None</c>.
            </p>
        </convention>
        <p>
            After the initialization method, we should provide some way for instances of <c>GaussianInteger</c> to be represented in a human-readable format. Otherwise, we'll see something like <c>&lt;__builtin__.GaussianInteger instance at 0x7f110b16cb90&gt;</c> as the value of an instance! Again, we use a built-in operator method for this, called <c>__repr__</c>. 
        </p>
        <listing>
            <program>
                <input>
                    class GaussianInteger:
                        
                        ...
                    
                        def __repr__(self):
                            plusminus = "+"
                            if self.imagpart &lt; 0:
                                plusminus = ""
                            return str(self.realpart) + plusminus + str(self.imagpart) + "*I"
                </input>
            </program>
            <caption>
                The <c>__repr__</c> method for <c>MyComplex</c>. The <c>...</c> which appears after the <c>class</c> line indicates that this is to be added to the previously-written class definition.
            </caption>
        </listing>
        
        <p>
            Generally, the <c>__repr__</c> method should return an unambiguous string representation of the object. Since the Gaussian integers are in bijective correspondence with the integer-coordinate points in the real plane, we could also have specified the return string to be <c>'('+str(self.realpart)+','+str(self.imagpart)+')'</c>, but what was given in the above listing is more elegant.
        </p>
        
        <p>
            Before we begin to discuss addition, subtraction, multiplication, and powers, we will define two methods for which there is not a built-in operator: the <em>norm</em>, and the <em>complex conjugate</em>.
        </p>
        <definition>
            <statement>
                <p>
                    If <m>z=x+iy</m> is any complex number, the <em>norm of <m>z</m></em> is 
                    <me>\abs{z} = \sqrt{(\Real z)^2 + (\Imag z)^2} = \sqrt{x^2+y^2}.</me>
                    The <em>complex conjugate of <m>z</m></em> is
                    <me>\bar{z} = \Real z - i(\Imag z) = x-iy.</me>
                </p>
            </statement>
        </definition>
        <p>
            Since there are not built-in methods for these, we will call the methods <c>norm</c> and <c>conj</c>.
        </p>
        <listing>
            <program>
                <input>
                    class GaussianInteger:
                    
                        ...
                    
                        def norm(self):
                            return sqrt(self.realpart^2 + self.imagpart^2)
                    
                        def conj(self):
                            return GaussianInteger(self.realpart, -self.imagpart)
                </input>
            </program>
            <caption>Extending the Gaussian integer class to define the <em>norm</em>. Note that we can take advantage of Sage's built in mathematical capabilities and use the <c>sqrt</c> function without having to load any extra <q>libraries.</q></caption>
        </listing>
        
        <p>
            A last pair of methods which we need to define for our Gaussian integer class allow us to avoid direct reference to the attributes of <c>GaussianInteger</c> objects. While Python allows us to reference attributes directly, it is generally considered to be bad practice, not least of all because other object-oriented programming languages forbid it. We will add a method <c>re</c> and a method <c>im</c> to access these attributes indirectly.
        </p>
        <listing>
            <program>
                <input>
                    class GaussianInteger:
                        '''My Gaussian integer class.
                        '''
                        def __init__(self, a, b):
                            '''The two arguments to initialize the GaussianInteger class must be integers.
                            '''
                            if type(a)==type(1) and type(b)==type(1):
                                self.realpart = a
                                self.imagpart = b
                            else:
                                raise ValueError('Both arguments to GaussianInteger(a,b) must be integers.')
                        
                        def __repr__(self):
                            plusminus = "+"
                            if self.imagpart &lt; 0:
                                plusminus = ""
                            return str(self.realpart) + plusminus + str(self.imagpart) + "*I"
                    
                        def norm(self):
                            return sqrt(self.realpart^2 + self.imagpart^2)

                        def conj(self):
                            return GaussianInteger(self.realpart, -self.imagpart)
                    
                        def re(self):
                            return self.realpart
                    
                        def im(self):
                            return self.imagpart
                </input>
            </program>
            <caption>A full listing of the <c>GaussianInteger</c> class to this point.</caption>
        </listing>
    </subsection>
    
    <subsection xml:id="sec-Functions-Classes-Afterword">
        <title>Extending the class</title>
        <p>
            In order to fully flesh out the Gaussian integer class, we will need the ability to redefine the standard addition operator to handle adding together two objects of <c>GaussianInteger</c> type. This idea is called <em>operator overloading</em> and is the topic of the final section of this chapter.
        </p> -->
</section>
