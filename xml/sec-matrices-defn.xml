<section>
    <subsection>
        <title>What is a matrix?</title>
        <p>
            A <em>matrix</em> is a rectangular grid of elements<fn>There's a much more technical definition, but for our purposes this is sufficient.</fn>; in our investigation, we will limit the elements to real numbers. For instance, and by way of demonstrating the form we will use to write a matrix,
            <me>
                A=\begin{bmatrix}\pi\amp  e\amp  6.2 \\ \frac13 \amp  7 \amp  -42
                \end{bmatrix}
            </me>
            and
            <me>
                B = \begin{bmatrix}1 \amp  0 \amp  0 \amp  0 \\ 0 \amp  1 \amp  0 \amp  0 \\ 0 \amp  0 \amp  1 \amp  0 \\ 0 \amp  0 \amp  0 \amp  1
                \end{bmatrix}
            </me>
            are matrices. Neither
            <me>
                C = \begin{bmatrix}5 \amp  8 \amp  \\ 2 \amp  3 \amp  0
                \end{bmatrix}
            </me>
            nor
            <me>
                D = \begin{bmatrix}\text{ Eric }  \amp  \text{ John }  \\ \text{ Graham }  \amp  \text{ Terry } 
                \end{bmatrix}
            </me>
            are matrices, the first because it is non-rectangular and the second because the names of members of Monty Python are not numbers.
        </p>

        <p>
            Matrices have many, many interesting properties. These can be investigated at length in a course on Matrix Theory (like Math 3203: Matrix Methods) or better yet in a course on Linear Algebra (like Math 3315: Linear Algebra). We will take an approach much more like Matrix Theory than Linear Algebra so that we can avoid most or all of the ``proofiness."
        </p>
    </subsection>
    <subsection>
    <title>How would a computer best represent a matrix?</title>
    <p>
        There is a sort of natural way to represent a matrix algorithmically, which arises from the way we refer to elements of a matrix. For instance, if we are working with a matrix <m>A</m> and are interested in the element of <m>A</m> in the <m>i^\text{ th }</m> row and <m>j^\text{ th }</m> column<fn>By convention rows are horizontal and columns vertical.</fn>, we might logically refer to it mathematically as the element <m>a_{i,j}</m>. The number of rows of <m>A</m> is its <em>row dimension</em>, and the number of columns of <m>A</m> is its <em>column dimension</em>. Hence if we have
        <me>
            A=\begin{bmatrix}\pi\amp  e\amp  6.2 \\ \frac13 \amp  7 \amp  -42
            \end{bmatrix}
        </me>
        we would say that <m>A</m> has row dimension <m>2</m> and column dimension <m>3</m>, or more concisely say that <m>A</m> is a <m>2\times 3</m> matrix. Row dimension is always listed first in this notation.
    </p>

    <p>
        Since we index the element in the <m>i^\text{ th }</m> row and <m>j^\text{ th }</m> column as <m>a_{i,j}</m>, it seems natural that the <m>i^\text{ th }</m> row should be something like a list. In fact, since we won't want to overwrite individual elements of a matrix, we'll use a tuple of tuples to store the elements. Without any validation of input, this would be easy enough. However, if we want to be careful, there are many things which could go wrong in trying to input a matrix which we want to protect against <mdash /> after all, we might use this matrix class later for something more fun!
    </p>

    <p>
        Here's a brief list of what could be incorrect input for a matrix:
        <ol>
            <li><p>The value input could not be have any elements (not a compound data type).</p></li>
            <li><p>The elements of the input value could not be compound types.</p></li>
            <li><p>The first element of the input could be an empty container, like <c>[ ]</c>.</p></li>
            <li><p>The length of the elements of the inputs could be different.</p></li>
            <li><p>The innermost elements could be non-numeric.</p></li>
        </ol>
    </p>

    <p>
        All of these errors are addressed in the following code, which you should save as <c>Matrix.py</c>.
    </p>
    <pre>
        class Matrix:
            """A matrix class.
            """
            def __init__(self, grid):
                input_err = '\n\nMatrix class requires rectangular grid of numbers '+\
                    'as input.\n\n'
                try:
                    # will raise error if not compound
                    self._coldim = len(grid[0])
                    if self._coldim==0: # empty first row
                        raise ValueError(input_err) 
                    self._data = []
                    for row in grid:
                        # check row length and that all row elements are numbers
                        if (len(row)!=self._coldim) or \
                            not all([type(x) in [float,int] for x in row]):
                            raise ValueError(input_err[2:-2]) 
                        else:
                            self._data.append(tuple(row))
                except:
                    print(input_err)
                    raise
                self._data = tuple(self._data)
                self._rowdim = len(grid)

            def __repr__(self):
                return str(self._data)
    </pre>
    <p>
        This code, like many, introduces a new command, <c>all</c>. This is a special boolean function which takes a compound object as its only argument. The effect of running <c>all</c> on a list <c>spam</c> would be to return <c>True</c> if and only if <c>bool(x)</c> returns <c>True</c> for every <c>x</c> in <c>spam</c>. We won't worry about producing a prettier output than provided by <c>Matrix.__repr__</c> at this point, so we'll leave <c>Matrix.__str__</c> undefined.
    </p>
</subsection>

</section>
