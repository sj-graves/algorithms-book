<?xml version="1.0" encoding="UTF-8"?>
<section xmlns:xi="http://www.w3.org/2001/XInclude" xml:id="s-MF-AP">
    <title>Augmenting flows</title>
    <introduction>
        <p>
            Recalling <xref ref="def-cap_net" />, specifically the definition of a flow on a network, we recognize that not every flow is a maximum flow; thereby if a flow on a capacitated network is not maximum, then it can be increased! All of the earliest algorithms solving the maximum flow problem are built on the idea of constructing an augmenting flow based upon a non-maximum valid flow. We begin with the <term>Ford-Fulkerson algorithm</term>.
        </p>
    </introduction>
    <subsection xml:id="ss-MF-AP-FF">
        <title>Ford-Fulkerson and Edmonds-Karp algorithms</title>
        <algorithm xml:id="alg-FordFulkerson">
            <title>Ford-Fulkerson algorithm</title>
            <idx>Ford-Fulkerson algorithm</idx>
            <idx>
                <h>algorithm</h>
                <h>Ford-Fulkerson</h>
            </idx>
            <statement>
                <p>
                    Suppose that <m>\Delta = (V,A,c,s,t)</m> is a capacitated network. 
                </p>
                <ol>
                    <li> 
                        Let <m>f:V\times V\to\R^{\geq 0}</m> be defined with <m>f(u,v)=0</m> for every pair <m>(u,v)\in V\times V</m>. This is the <term>flow</term> on <m>\Delta</m>, which will be modified as the algorithm proceeds.
                    </li>
                    <li> Let <m>A^{-1}=\set{(v,u):(u,v)\in A}</m> be the set of reversed arrows of <m>\Delta.</m>
                        Define a function <m>c_f:V\times V\to\R^+</m> such that
                        <me>
                            c_f(u,v) = \left\{
                            \begin{array}{l@{~}l}
                            c(u,v) - f(u,v), \amp (u,v)\in A \\
                            f(v,u), \amp (u,v)\in A^{-1} \\
                            0, \amp (u,v)\notin A\cup A^{-1}
                            \end{array}
                            \right.
                        </me>
                        This is the <term>residual capacity</term><idx><h>capacity function</h><h>residual</h></idx> on <m>\Delta</m> under the flow <m>f</m>.
                    </li>
                    <li>
                        <p>
                            Until a maximum flow is found, repeat the following:
                        </p>
                        <ol>
                            <li>
                                Find an <term>augmenting <m>(s,t)</m>-path</term>, denoted 
                                <me>P=\set{s=v_0,v_1,v_2,\dotsc,v_k=t},</me> 
                                such that for each <m>i\in \set{0,1,2,\dotsc, k-1}</m> the residual capacity of the <m>i^\text{th}</m> 
                                arrow is positive; that is, <m>c_f(v_i,v_{i+1})>0</m>. 
                                <em>If no such <m>P</m> can be found, the flow <m>f</m> is maximum.</em>
                            </li>
                            <li>
                                Let 
                                <m>w = \min\set{c_f(u_i,u_{i+1}):i\in\set{0,1,\dotsc,k-1}}.</m>
                            </li>
                            <li>
                                Augment the flow <m>f</m> on every edge of <m>P</m>; that is, for <m>i\in\set{0,1,\dotsc,k-1}</m> increase <m>f(u_i,u_{i+1)})</m> by <m>w</m>.
                            </li>
                        </ol>
                        </li>
                </ol>
            </statement>
        </algorithm>
        <p>
            While this is properly an algorithm, it leaves out a crucial step: how does one find an augmenting <m>(s,t)</m>-path? Since the graphs in question are finite, one method was proposed by Jack Edmonds and Richard Karp in 1972: use a Dijkstra-style breadth-first search. Recall that <xref provisional="alg-Dijkstra" /> when run to completion provides the shortest path from a source vertex to every other vertex in a connected graph; we can stop as soon as we find <m>t</m>, which improves the run time of the algorithm. By specifiying which augmenting paths to use, the Edmonds-Karp algorithm side-steps the hon-halting issue in Ford-Fulkerson.
        </p>
    </subsection>
    <subsection xml:id="ss-MF-AF-FFF">
        <title>Failure of Ford-Fulkerson</title>
        <p>
            Consider the capacitated network <m>\Delta = (V,A,c,1,4)</m> given below, and let's use the Ford-Fulkerson algorithm to compute a maximum flow. The number <m>r=\frac12(\sqrt{5}-1)</m> is not arbitrary, but in fact is a solution to <m>r^2 = 1-r</m>. Rather than following a reasonable rule, let's prescribe the augmenting paths.
        </p>
        <figure xml:id="fig-fordfulkfail-s0">
            <caption>A smallest capacitated network for which the Ford-Fulkerson algorithm will fail to terminate, when <m>r = \frac12(\sqrt{5}-1)\approx .62</m>.</caption>
            <image xml:id="img-fordfulkfail" width="50%">
                <description>
                    A smallest capacitated network for which the Ford-Fulkerson algorithm will fail to terminate, with edges
                </description>
                <latex-image>
                    \tiny
                    \tikzset{ vstyle0/.style = {fill=white,draw=black,circle,inner sep=1pt, outer sep=0pt} }
                    \begin{tikzpicture}[scale=2]
                    \path \foreach \n/\x/\y in {0/0.0/0.0, 1/0.0/1.0, 2/0.5/0.667, 3/0.5/0.333, 4/1.0/0.0, 5/1.0/1.0} 
                        { (\x,\y) node [vstyle0] (\n)  {\tt\n}};

                    \begin{scope}[on background layer]
                    \graph[edge quotes = {blue, fill=white, inner sep = 1pt}, edges = {black, -{Stealth}}]{
                    (0) ->["\tt 4"] {(1),(3),(4)},
                    (1) ->["\tt 4"] (5),
                    (2) ->["\tt 4"] (5),
                    (4) ->["\tt 4"] (5),
                    (1) ->["$r$"] (2),
                    (3) ->["\tt 1"] {(2),(4)},
                    };

                    \end{scope}
                    \end{tikzpicture}
                </latex-image>
            </image>
        </figure>
        <p>
            Beginning with the zero flow, we choose as our first augmenting path <me>P_0 = \set{0,3,2,5}, w=1.</me> This <term>saturates</term> the edges <m>(3,2)</m> so that the flow on the edge equals its capacity. The arrows of interest in this graph will always be <m>(1,2)</m>, <m>(3,2)</m>, and <m>(3,4)</m>.
        </p>
        <xi:include href="./tab-maxflow-augpath.xml" />
    </subsection>
</section>