<section xml:id="s-FP-FDT">
    <title>Functions do things</title>


    <introduction>
        <p>
            Examples of mathematical functions abound, and you have probably spent the last several years as a mathematics student learning about the behavior of all sorts of different functions: polynomials, rational functions, trigonometric functions, exponential functions, and logarithms, just to name a few. These functions all have some things in common. They all take as input a single number, usually a real number (although each of the listed functions has an extension into the complex numbers). Moreover, they all return as output exactly one real number for each real number input. Multivariate calculus introduces the idea of functions with more than one input variable (sometimes written using vector notation) and then later introduces the idea of vector-valued functions. For instance, a nice multivariate calculus function example is
            <me>\vec{f}(x,y) = \begin{bmatrix} x^2\\ -\frac{x}{y} \end{bmatrix}.</me>
        </p>
        <p>
            Since Sage does symbolic math, it can do all this, but since Sage is also a full programming language it also has a means to use the word <em>function</em> to mean something else, which is often called a <term>subroutine</term>. We'll generally continue to call these functions as the usage is essentially the same for a subroutine in Sage as a mathematical function: the function name first, followed by a comma-separated sequence of inputs, called <term>arguments</term>.
        </p>
        <p>
            Symbolic functions like those used in Calculus are very, very easy to define in Sage.
        </p>
        <sage>
            <input>
                x = var('x')
                f(x) = 1+x^2 + x^3
                print f
                print f(3)
                print f(x^2)
            </input>
        </sage>
    </introduction>

    <subsection xml:id='ss-FP-FDT-DS'>
        <title>Defining subroutines</title>
        <p>
            More often than not, a single line of code doesn't suffice to solve a problem. The <c>def my_func(...):</c>  block structure provides the ability to write more complicated procedures as reusable subroutines. Let's investigate a simple function <c>fib</c> to understand the structure of a function written using <c>def</c>.
        </p>
<!--         <listing> -->
<!--             <program> -->
<!--                 <input> -->
<!--                     def fib(n): -->
<!--                         '''A mysterious function appears! -->
<!--  -->
<!--                         The argument n must be a positive integer. -->
<!--                         ''' -->
<!--                         if type(n) == type(1) and n &gt; 0: -->
<!--                             sequence = [0,1] -->
<!--                             while len(sequence) &lt; n: -->
<!--                                 sequence += [sequence[-2]+sequence[-1]] -->
<!--                             return sequence[-1] -->
<!--                         else: -->
<!--                             raise TypeError('Function fib expects positive integer.') -->
<!--                 </input> -->
<!--             </program> -->
<!--             <caption> -->
<!--                 A function written using the <c>def</c> command. -->
<!--             </caption> -->
<!--         </listing> -->
        <sage>
            <input>
                def fibo(n):
                    """Return the n-th element in the Fibonacci sequence with initial values 0 and 1.
                
                    The argument n should be a positive integer.
                    """
                    try:
                        if n > 0:
                            sequence = [0, 1]
                            while len(sequence) &lt; n:
                                sequence.append( sequence[-1] + sequence[-2] )
                            return sequence[n]
                    except:
                    
            </input>
        </sage>
        <p></p>
        <p>
            The first line consists of <c>def fib(n):</c>, which uses the <c>def</c> command to define a function whose name is <c>fib</c> and which takes exactly one argument, <c>n</c>. The value of this argument must be given when the function is used, or a <c>TypeError</c> will be raised. This is followed by a multiline string enclosed in <c>'''</c>; when this string appears in a function definition it is called the <em>docstring</em>, or <em>documentation string</em>, and provides the text for the <c>help</c> function when used interactively. In this case, if we want to see the help for <c>fib</c> after the function has been defined, we would type <c>help(fib)</c>. 
        </p>
        <p>
            After the docstring, our function contains an if statement which compares <c>type(n)</c> to <c>type(1)</c>. If they are of the same type, then the if statement proceeds to check also whether <c>n</c> is positive.
            <fn>
                If <c>p</c> and <c>q</c> are Boolean, <c>p and q</c> is true if and only if both <c>p</c> and <c>q</c> are true. Hence if the first argument <c>p</c> is false then there is no need to test the second argument. Similarly, <c>p or q</c> is true as long as at least one of <c>p</c> or <c>q</c> is true. Hence if the first argument is true, then the second argument is not tested.
            </fn>
            This if statement provides <em>input validation</em> to check whether the value passed into the argument is as expected when writing the function. Supposing the value of <c>n</c> is as expected, the first statement inside the if block sets the value of <c>sequence</c> to <c>[0,1]</c>. Then as long as the length of <c>sequence</c>, found by calling <c>len(sequence)</c>, is less than the input value <c>n</c>, the sum of the last two values of <c>sequence</c> is included at the end of <c>sequence</c>. After the while loop finishes executing, the last value of <c>sequence</c> is returned.
        </p>
        <p>
            If the input validation failed because the input value of the argument to <c>fib</c> was either not an integer or was not positive, then the else block executes and a <c>TypeError</c> is raised; the argument to the <c>TypeError</c> is the displayed error message.
        </p>
        <p>
            Generally speaking, this structure is what every function will follow! You'll pass in some arguments, maybe do some type checking, and then run an algorithm on the arguments. When you complete the algorithm, you return something. Functions which reach the end of their <c>def</c> block without executing an explicit <c>return</c> statement return the special value <c>None</c> of <c>NoneType</c>.
        </p>
    </subsection>
    

    <subsection xml:id="ss-FP-FDT-LF">
        <title>Lambda functions</title>
        <p>
            Let's say we want to define a function <m>f</m> which takes two arguments, <m>n</m> and <m>x</m>, and returns <m>nx</m>. Mathematically, this is simple: let <m>f(n,x)=nx</m>. When we need to define such a simple function for our own use in a Sage program, we can define <m>f</m> in almost the same way.
        </p>
        <sage>
            <input>
                f = lambda n,x: n*x
                print f(4,12)
                print f(4,'foo')
                print f([4],'foo')
            </input>
        </sage>
        <p>
            The limitation that a <c>lambda</c> expression cannot contain more than one line of code is clearly seen here to be a limitation. We cannot include a <c>try</c> block to handle the exception raised when we try to multiply objects of incompatible types! It is so definitely not a block structure that attempting to use indentation to create such structure while using <c>lambda</c> will generate a <c>SyntaxError</c>.
        </p>
        <sage>
            <input>
                f = lambda n,x:
                    n*x
            </input>
        </sage>
        <p>
            The variable names which occur between <c>lambda</c> and <c>:</c> are the tuple of arguments to the lambda function, and since they are considered to be a tuple they are indexed by position. While the limitation that a lambda function must consist of a single line seems severe, there is enough flexibility in the underlying Python language to allow a significant amount of power.
        </p>
        <example>
            <title>A recursive lambda function</title>
            <p>
                A function is <em>recursive</em> if it uses the principle of mathematical induction to be evaluated. Such a recursive function <c>rec</c> would call itself on a <q>smaller</q> input unless the input is already somehow <q>smallest.</q>
            </p>
            <listing xml:id="listing-Recursive-Euclid-GCD">
                <program>
                    <input>
                        rec = lambda a,b: b if a%b==0 else rec(b,a%b)
                    </input>
                </program>
                <caption>A recursive function</caption>
            </listing>
            <p>
                Let's restrict the arguments to positive integers <m>a</m> and <m>b</m>. We must remember that the binary operator <c>%</c> in Sage returns the remainder of integer division. Hence <c>7 % 3</c> evaluates to <c>1</c>, since <m>7 = 3(2)+1</m>. With this in mind, what is the behavior of the code structure which follows?
            </p>
            <program>
                <input>
                    variable = first_value if second_value else third_value
                </input>
            </program>
            <p>
                This is a complicated statement, but it is equivalent to writing the following code.
            </p>
            <program>
                <input>
                if second_value:
                    variable = first_value
                else:
                    variable = third_value
                </input>
            </program>
            <p>
                Hopefully you can see the benefit in the more compact form of writing this. As they are equivalent, the shorter form is never necessary, but sometimes it is used in an effort to make code more <q>elegant</q>. With that in mind, can you determine what the final return value of <C>rec(51,1734)</C> would be? What about the general behavior of <c>rec(x,y)</c> if <c>x</c> and <c>y</c> are both defined to be positive integers?
            </p>
        </example>
    </subsection>


    <subsection xml:id="sec-Functions-Functions-Reusability">
        <title>Writing reusable code</title>
        <p>
            While it is not always the case that you need to reuse a program, it is definitely of worth to consider several questions. Will writing the program to solve exactly one problem be quicker than solving the single problem analytically, or is there no known analytic solution? Is the algorithm much more difficult to solve in the general case, or at least a more general case than the single problem, and is it instructive to consider the more general solution? If it is the case that the program you are considering will be useful more than once, you should strongly consider writing it in such a way that you can reuse the code. In Sage, this is most effectively done by writing your functions in a separate file with the extension <c>.sage</c>, for example <c>my_functions.sage</c>, and then when you need to use them in a different worksheet (in the same directory) you can access the functions by using the command <c>load('my_functions.sage')</c>.
        </p>
        <p>
            The example function <c>rec</c> from the previous section is interesting, as it provides a very short implementation of Euclid's algorithm for calculating the greatest common divisor of two integers. If this function definition is written only in Sage worksheet (a <c>.sagews</c> file), then it is <q>inaccessible</q> for other worksheets and would need to be copied and pasted from worksheet to worksheet. While this works, it is an inelegant solution. It is better to open a new file with the extension <c>.sage</c> and then, when the functions defined in that file are needed, to use the <c>load</c> command to access those functions. For instance, if <c>rec_euclid.sage</c> is a file in your home directory (on Unix-based systems like Linux and Mac OS, this is accessed at <c>~</c>), you would load the definitions of <c>rec</c> from <c>rec_euclid.sage</c> by calling <c>load('~/rec_euclid.sage')</c>.
        </p>

        <historical xml:id="historical-Euclid">
            <title>Euclid of Alexandria</title>
            <p>
                While we here refer to Euclid for his number theoretic algorithm to calculate the greatest common divisor of integers, his true fame lies in authoring the <em>Elements</em>. Until educational methods changed drastically in the twentieth century, Euclid's <em>Elements</em> was considered to be a standard part of the curriculum of every educated person. Originally written sometime circa 300 B.C., the geometry of Euclid was part of the <em>quadrivium</em>, the second stage of the liberal arts education, until modern educational methods supplanted the classical style at the turn of the twentieth century.
            </p>
        </historical>
    </subsection>
</section>
